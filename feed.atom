<feed xmlns="http://www.w3.org/2005/Atom"><title>The Go Blog</title><id>tag:blog.golang.org,2013:blog.golang.org</id><link rel="self" href="https://go.dev/blog/feed.atom"></link><updated>2024-02-22T00:00:00+00:00</updated><entry><title>Robust generic functions on slices</title><id>tag:blog.golang.org,2013:blog.golang.org/generic-slice-functions</id><link rel="alternate" href="https://go.dev/blog/generic-slice-functions"></link><published>2024-02-22T00:00:00+00:00</published><updated>2024-02-22T00:00:00+00:00</updated><author><name></name></author><summary type="html">Avoiding memory leaks in the slices package.</summary><content type="html">&#xA;&lt;div id=&#34;blog&#34;&gt;&lt;div id=&#34;content&#34;&gt;&#xA;  &lt;div id=&#34;content&#34;&gt;&#xA;&#xA;    &lt;div class=&#34;Article&#34; data-slug=&#34;/blog/generic-slice-functions&#34;&gt;&#xA;    &#xA;    &lt;h1 class=&#34;small&#34;&gt;&lt;a href=&#34;/blog/&#34;&gt;The Go Blog&lt;/a&gt;&lt;/h1&gt;&#xA;    &#xA;&#xA;    &lt;h1&gt;Robust generic functions on slices&lt;/h1&gt;&#xA;      &#xA;      &lt;p class=&#34;author&#34;&gt;&#xA;      Valentin Deleplace&lt;br&gt;&#xA;      22 February 2024&#xA;      &lt;/p&gt;&#xA;      &#xA;      &lt;p&gt;The &lt;a href=&#34;/pkg/slices&#34;&gt;slices&lt;/a&gt; package provides functions that work for slices of any type.&#xA;In this blog post we&amp;rsquo;ll discuss how you can use these functions more effectively by understanding how slices are represented in memory and how that affects the garbage collector, and we&amp;rsquo;ll cover how we recently adjusted these functions to make them less surprising.&lt;/p&gt;&#xA;&lt;p&gt;With &lt;a href=&#34;/blog/deconstructing-type-parameters&#34;&gt;Type parameters&lt;/a&gt; we can write functions like &lt;a href=&#34;/pkg/slices#Index&#34;&gt;slices.Index&lt;/a&gt; once for all types of slices of comparable elements:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;// Index returns the index of the first occurrence of v in s,&#xA;// or -1 if not present.&#xA;func Index[S ~[]E, E comparable](s S, v E) int {&#xA;    for i := range s {&#xA;        if v == s[i] {&#xA;            return i&#xA;        }&#xA;    }&#xA;    return -1&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;It is no longer necessary to implement &lt;code&gt;Index&lt;/code&gt; again for each different type of element.&lt;/p&gt;&#xA;&lt;p&gt;The &lt;a href=&#34;/pkg/slices&#34;&gt;slices&lt;/a&gt; package contains many such helpers to perform common operations on slices:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;    s := []string{&amp;quot;Bat&amp;quot;, &amp;quot;Fox&amp;quot;, &amp;quot;Owl&amp;quot;, &amp;quot;Fox&amp;quot;}&#xA;    s2 := slices.Clone(s)&#xA;    slices.Sort(s2)&#xA;    fmt.Println(s2) // [Bat Fox Fox Owl]&#xA;    s2 = slices.Compact(s2)&#xA;    fmt.Println(s2)                  // [Bat Fox Owl]&#xA;    fmt.Println(slices.Equal(s, s2)) // false&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Several new functions (&lt;code&gt;Insert&lt;/code&gt;, &lt;code&gt;Replace&lt;/code&gt;, &lt;code&gt;Delete&lt;/code&gt;, etc.) modify the slice. To understand how they work, and how to properly use them, we need to examine the underlying structure of slices.&lt;/p&gt;&#xA;&lt;p&gt;A slice is a view of a portion of an array. &lt;a href=&#34;/blog/slices-intro&#34;&gt;Internally&lt;/a&gt;, a slice contains a pointer, a length, and a capacity. Two slices can have the same underlying array, and can view overlapping portions.&lt;/p&gt;&#xA;&lt;p&gt;For example, this slice &lt;code&gt;s&lt;/code&gt; is a view on 4 elements of an array of size 6:&lt;/p&gt;&#xA;&lt;div class=&#34;image&#34;&gt;&#xA;  &lt;img src=&#34;generic-slice-functions/1_sample_slice_4_6.svg&#34; width=&#34;450&#34; alt=&#34;&#34;&gt;&#xA;&lt;/div&gt;&#xA;&lt;p&gt;If a function changes the length of a slice passed as a parameter, then it needs to return a new slice to the caller. The underlying array may remain the same if it doesn&amp;rsquo;t have to grow. This explains why &lt;a href=&#34;/blog/slices&#34;&gt;append&lt;/a&gt; and &lt;code&gt;slices.Compact&lt;/code&gt; return a value, but &lt;code&gt;slices.Sort&lt;/code&gt;, which merely reorders the elements, does not.&lt;/p&gt;&#xA;&lt;p&gt;Consider the task of deleting a portion of a slice. Prior to generics, the standard way to delete the portion &lt;code&gt;s[2:5]&lt;/code&gt; from the slice &lt;code&gt;s&lt;/code&gt; was to call the &lt;a href=&#34;/ref/spec#Appending_and_copying_slices&#34;&gt;append&lt;/a&gt; function to copy the end portion over the middle portion:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;s = append(s[:2], s[5:]...)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;The syntax was complex and error-prone, involving subslices and a variadic parameter. We added &lt;a href=&#34;/pkg/slices#Delete&#34;&gt;slice.Delete&lt;/a&gt; to make it easier to delete elements:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;func Delete[S ~[]E, E any](s S, i, j int) S {&#xA;       return append(s[:i], s[j:]...)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;The one-line function &lt;code&gt;Delete&lt;/code&gt; more clearly expresses the programmer&amp;rsquo;s intent. Let’s consider a slice &lt;code&gt;s&lt;/code&gt; of length 6 and capacity 8, containing pointers:&lt;/p&gt;&#xA;&lt;div class=&#34;image&#34;&gt;&#xA;  &lt;img src=&#34;generic-slice-functions/2_sample_slice_6_8.svg&#34; width=&#34;600&#34; alt=&#34;&#34;&gt;&#xA;&lt;/div&gt;&#xA;&lt;p&gt;This call deletes the elements at &lt;code&gt;s[2]&lt;/code&gt;, &lt;code&gt;s[3]&lt;/code&gt;, &lt;code&gt;s[4]&lt;/code&gt;  from the slice &lt;code&gt;s&lt;/code&gt;:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;s = slices.Delete(s, 2, 5)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;div class=&#34;image&#34;&gt;&#xA;  &lt;img src=&#34;generic-slice-functions/3_delete_s_2_5.svg&#34; width=&#34;600&#34; alt=&#34;&#34;&gt;&#xA;&lt;/div&gt;&#xA;&lt;p&gt;The gap at the indices 2, 3, 4 is filled by shifting the element &lt;code&gt;s[5]&lt;/code&gt; to the left, and setting the new length to &lt;code&gt;3&lt;/code&gt;.&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;Delete&lt;/code&gt; need not allocate a new array, as it shifts the elements in place. Like &lt;code&gt;append&lt;/code&gt;, it returns a new slice. Many other functions in the &lt;code&gt;slices&lt;/code&gt; package follow this pattern, including &lt;code&gt;Compact&lt;/code&gt;, &lt;code&gt;CompactFunc&lt;/code&gt;, &lt;code&gt;DeleteFunc&lt;/code&gt;, &lt;code&gt;Grow&lt;/code&gt;, &lt;code&gt;Insert&lt;/code&gt;, and &lt;code&gt;Replace&lt;/code&gt;.&lt;/p&gt;&#xA;&lt;p&gt;When calling these functions we must consider the original slice invalid, because the underlying array has been modified. It would be a mistake to call the function but ignore the return value:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;    slices.Delete(s, 2, 5) // incorrect!&#xA;    // s still has the same length, but modified contents&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;a-problem-of-unwanted-liveness&#34;&gt;A problem of unwanted liveness&lt;/h2&gt;&#xA;&lt;p&gt;Before Go 1.22, &lt;code&gt;slices.Delete&lt;/code&gt; didn&amp;rsquo;t modify the elements between the new and original lengths of the slice. While the returned slice wouldn&amp;rsquo;t include these elements, the &amp;ldquo;gap&amp;rdquo; created at the end of the original, now-invalidated slice continued to hold onto them. These elements could contain pointers to large objects (a 20MB image), and the garbage collector would not release the memory associated with these objects. This resulted in a memory leak that could lead to significant performance issues.&lt;/p&gt;&#xA;&lt;p&gt;In this above example, we’re successfully deleting the pointers &lt;code&gt;p2&lt;/code&gt;, &lt;code&gt;p3&lt;/code&gt;, &lt;code&gt;p4&lt;/code&gt; from &lt;code&gt;s[2:5]&lt;/code&gt;, by shifting one element to the left. But &lt;code&gt;p3&lt;/code&gt; and &lt;code&gt;p4&lt;/code&gt; are still present in the underlying array, beyond the new length of &lt;code&gt;s&lt;/code&gt;. The garbage collector won’t reclaim them. Less obviously, &lt;code&gt;p5&lt;/code&gt; is not one of the deleted elements, but its memory may still leak because of the &lt;code&gt;p5&lt;/code&gt; pointer kept in the gray part of the array.&lt;/p&gt;&#xA;&lt;p&gt;This could be confusing for developers, if they were not aware that &amp;ldquo;invisible&amp;rdquo; elements were still using memory.&lt;/p&gt;&#xA;&lt;p&gt;So we had two options:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Either keep the efficient implementation of &lt;code&gt;Delete&lt;/code&gt;. Let users set obsolete pointers to &lt;code&gt;nil&lt;/code&gt; themselves, if they want to make sure the values pointed to can be freed.&lt;/li&gt;&#xA;&lt;li&gt;Or change &lt;code&gt;Delete&lt;/code&gt; to always set the obsolete elements to zero. This is extra work, making &lt;code&gt;Delete&lt;/code&gt; slightly less efficient. Zeroing pointers (setting them to &lt;code&gt;nil&lt;/code&gt;) enables the garbage collection of the objects, when they become otherwise unreachable.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;It was not obvious which option was best. The first one provided performance by default, and the second one provided memory frugality by default.&lt;/p&gt;&#xA;&lt;h2 id=&#34;the-fix&#34;&gt;The fix&lt;/h2&gt;&#xA;&lt;p&gt;A key observation is that &amp;ldquo;setting the obsolete pointers to &lt;code&gt;nil&lt;/code&gt;&amp;rdquo; is not as easy as it seems. In fact, this task is so error-prone that we should not put the burden on the user to write it. Out of pragmatism, we chose to modify the implementation of the five functions &lt;code&gt;Compact&lt;/code&gt;, &lt;code&gt;CompactFunc&lt;/code&gt;, &lt;code&gt;Delete&lt;/code&gt;, &lt;code&gt;DeleteFunc&lt;/code&gt;, &lt;code&gt;Replace&lt;/code&gt; to &amp;ldquo;clear the tail&amp;rdquo;. As a nice side effect, the cognitive load is reduced and users now don’t need to worry about these memory leaks.&lt;/p&gt;&#xA;&lt;p&gt;In Go 1.22, this is what the memory looks like after calling Delete:&lt;/p&gt;&#xA;&lt;div class=&#34;image&#34;&gt;&#xA;  &lt;img src=&#34;generic-slice-functions/4_delete_s_2_5_nil.svg&#34; width=&#34;600&#34; alt=&#34;&#34;&gt;&#xA;&lt;/div&gt;&#xA;&lt;p&gt;The code changed in the five functions uses the new built-in function &lt;a href=&#34;/pkg/builtin#clear&#34;&gt;clear&lt;/a&gt; (Go 1.21) to set the obsolete elements to the zero value of the element type of &lt;code&gt;s&lt;/code&gt;:&lt;/p&gt;&#xA;&lt;div class=&#34;image&#34;&gt;&#xA;  &lt;img src=&#34;generic-slice-functions/5_Delete_diff.png&#34; width=&#34;800&#34; alt=&#34;&#34;&gt;&#xA;&lt;/div&gt;&#xA;&lt;p&gt;The zero value of &lt;code&gt;E&lt;/code&gt; is &lt;code&gt;nil&lt;/code&gt; when &lt;code&gt;E&lt;/code&gt; is a type of pointer, slice, map, chan, or interface.&lt;/p&gt;&#xA;&lt;h2 id=&#34;tests-failing&#34;&gt;Tests failing&lt;/h2&gt;&#xA;&lt;p&gt;This change has led to some tests that passed in Go 1.21 now failing in Go 1.22, when the slices functions are used incorrectly. This is good news. When you have a bug, tests should let you know.&lt;/p&gt;&#xA;&lt;p&gt;If you ignore the return value of &lt;code&gt;Delete&lt;/code&gt;:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;slices.Delete(s, 2, 3)  // !! INCORRECT !!&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;then you may incorrectly assume that &lt;code&gt;s&lt;/code&gt; does not contain any nil pointer. &lt;a href=&#34;/play/p/NDHuO8vINHv&#34;&gt;Example in the Go Playground&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;p&gt;If you ignore the return value of &lt;code&gt;Compact&lt;/code&gt;:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;slices.Sort(s) // correct&#xA;slices.Compact(s) // !! INCORRECT !!&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;then you may incorrectly assume that &lt;code&gt;s&lt;/code&gt; is properly sorted and compacted. &lt;a href=&#34;/play/p/eFQIekiwlnu&#34;&gt;Example&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;p&gt;If you assign the return value of &lt;code&gt;Delete&lt;/code&gt; to another variable, and keep using the original slice:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;u := slices.Delete(s, 2, 3)  // !! INCORRECT, if you keep using s !!&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;then you may incorrectly assume that &lt;code&gt;s&lt;/code&gt; does not contain any nil pointer. &lt;a href=&#34;/play/p/rDxWmJpLOVO&#34;&gt;Example&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;p&gt;If you accidentally shadow the slice variable, and keep using the original slice:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;s := slices.Delete(s, 2, 3)  // !! INCORRECT, using := instead of = !!&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;then you may incorrectly assume that &lt;code&gt;s&lt;/code&gt; does not contain any nil pointer. &lt;a href=&#34;/play/p/KSpVpkX8sOi&#34;&gt;Example&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;&#xA;&lt;p&gt;The API of the &lt;code&gt;slices&lt;/code&gt; package is a net improvement over the traditional pre-generics syntax to delete or insert elements.&lt;/p&gt;&#xA;&lt;p&gt;We encourage developers to use the new functions, while avoiding the &amp;ldquo;gotchas&amp;rdquo; listed above.&lt;/p&gt;&#xA;&lt;p&gt;Thanks to the recent changes in the implementation, a class of memory leaks is automatically avoided, without any change to the API, and with no extra work for the developers.&lt;/p&gt;&#xA;&lt;h2 id=&#34;further-reading&#34;&gt;Further reading&lt;/h2&gt;&#xA;&lt;p&gt;The signature of the functions in the &lt;code&gt;slices&lt;/code&gt; package is heavily influenced by the specifics of the representation of slices in memory. We recommend reading&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;/blog/slices-intro&#34;&gt;Go Slices: usage and internals&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;/blog/slices&#34;&gt;Arrays, slices: The mechanics of &amp;lsquo;append&amp;rsquo;&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;The &lt;a href=&#34;https://en.wikipedia.org/wiki/Dynamic_array&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;dynamic array&lt;/a&gt; data structure&lt;/li&gt;&#xA;&lt;li&gt;The &lt;a href=&#34;/pkg/slices&#34;&gt;documentation&lt;/a&gt; of the package slices&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;The &lt;a href=&#34;/issue/63393&#34;&gt;original proposal&lt;/a&gt; about zeroing obsolete elements contains many details and comments.&lt;/p&gt;&#xA;&#xA;    &lt;/div&gt;&#xA;&#xA;    &#xA;    &lt;div class=&#34;Article prevnext&#34;&gt;&#xA;    &#xA;    &#xA;      &#xA;        &lt;p&gt;&#xA;        &#xA;        &#xA;          &#xA;            &lt;b&gt;Previous article: &lt;/b&gt;&lt;a href=&#34;/blog/routing-enhancements&#34;&gt;Routing Enhancements for Go 1.22&lt;/a&gt;&lt;br&gt;&#xA;          &#xA;        &#xA;        &lt;b&gt;&lt;a href=&#34;/blog/all&#34;&gt;Blog Index&lt;/a&gt;&lt;/b&gt;&#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;    &lt;/div&gt;&#xA;    &#xA;&#xA;  &lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;script src=&#34;/js/jquery.js&#34;&gt;&lt;/script&gt;&#xA;&lt;script src=&#34;/js/playground.js&#34;&gt;&lt;/script&gt;&#xA;&lt;script src=&#34;/js/play.js&#34;&gt;&lt;/script&gt;&#xA;&lt;script src=&#34;/js/godocs.js&#34;&gt;&lt;/script&gt;&#xA;&#xA;</content></entry><entry><title>Routing Enhancements for Go 1.22</title><id>tag:blog.golang.org,2013:blog.golang.org/routing-enhancements</id><link rel="alternate" href="https://go.dev/blog/routing-enhancements"></link><published>2024-02-13T00:00:00+00:00</published><updated>2024-02-13T00:00:00+00:00</updated><author><name></name></author><summary type="html">Go 1.22&amp;#39;s additions to patterns for HTTP routes.</summary><content type="html">&#xA;&lt;div id=&#34;blog&#34;&gt;&lt;div id=&#34;content&#34;&gt;&#xA;  &lt;div id=&#34;content&#34;&gt;&#xA;&#xA;    &lt;div class=&#34;Article&#34; data-slug=&#34;/blog/routing-enhancements&#34;&gt;&#xA;    &#xA;    &lt;h1 class=&#34;small&#34;&gt;&lt;a href=&#34;/blog/&#34;&gt;The Go Blog&lt;/a&gt;&lt;/h1&gt;&#xA;    &#xA;&#xA;    &lt;h1&gt;Routing Enhancements for Go 1.22&lt;/h1&gt;&#xA;      &#xA;      &lt;p class=&#34;author&#34;&gt;&#xA;      Jonathan Amsterdam, on behalf of the Go team&lt;br&gt;&#xA;      13 February 2024&#xA;      &lt;/p&gt;&#xA;      &#xA;      &lt;p&gt;Go 1.22 brings two enhancements to the &lt;code&gt;net/http&lt;/code&gt; package&amp;rsquo;s router: method&#xA;matching and wildcards. These features let you express common routes as&#xA;patterns instead of Go code. Although they are simple to explain and use,&#xA;it was a challenge to come up with the right rules for selecting the winning&#xA;pattern when several match a request.&lt;/p&gt;&#xA;&lt;p&gt;We made these changes as part of our continuing effort to make Go a great&#xA;language for building production systems. We studied many third-party web&#xA;frameworks, extracted what we felt were the most used features, and integrated&#xA;them into &lt;code&gt;net/http&lt;/code&gt;. Then we validated our choices and improved our design by&#xA;collaborating with the community in a &lt;a href=&#34;https://github.com/golang/go/discussions/60227&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;GitHub discussion&lt;/a&gt; and a &lt;a href=&#34;/issue/61410&#34;&gt;proposal issue&lt;/a&gt;.&#xA;Adding these features to the standard library means one fewer dependency for&#xA;many projects. But third-party web frameworks remain a fine choice for current&#xA;users or programs with advanced routing needs.&lt;/p&gt;&#xA;&lt;h2 id=&#34;enhancements&#34;&gt;Enhancements&lt;/h2&gt;&#xA;&lt;p&gt;The new routing features almost exclusively affect the pattern string passed&#xA;to the two &lt;code&gt;net/http.ServeMux&lt;/code&gt; methods &lt;code&gt;Handle&lt;/code&gt; and &lt;code&gt;HandleFunc&lt;/code&gt;, and the&#xA;corresponding top-level functions &lt;code&gt;http.Handle&lt;/code&gt; and &lt;code&gt;http.HandleFunc&lt;/code&gt;. The only&#xA;API changes are two new methods on &lt;code&gt;net/http.Request&lt;/code&gt; for working with wildcard&#xA;matches.&lt;/p&gt;&#xA;&lt;p&gt;We&amp;rsquo;ll illustrate the changes with a hypothetical blog server in which every post&#xA;has an integer identifier. A request like &lt;code&gt;GET /posts/234&lt;/code&gt; retrieves the post with&#xA;ID 234. Before Go 1.22, the code for handling those requests would start with a&#xA;line like this:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;http.Handle(&amp;quot;/posts/&amp;quot;, handlePost)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;The trailing slash routes all requests beginning &lt;code&gt;/posts/&lt;/code&gt; to the &lt;code&gt;handlePost&lt;/code&gt;&#xA;function, which would have to check that the HTTP method was GET, extract&#xA;the identifier, and retrieve the post. Since the method check isn&amp;rsquo;t strictly&#xA;necessary to satisfy the request, it would be a natural mistake to omit it. That&#xA;would mean that a request like &lt;code&gt;DELETE /posts/234&lt;/code&gt; would fetch the post, which&#xA;is surprising at the least.&lt;/p&gt;&#xA;&lt;p&gt;In Go 1.22, the existing code will continue to work, or you could instead write this:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;http.Handle(&amp;quot;GET /posts/{id}&amp;quot;, handlePost2)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;This pattern matches a GET request whose path begins &amp;ldquo;/posts/&amp;rdquo; and has two&#xA;segments. (As a special case, GET also matches HEAD; all the other methods match&#xA;exactly.) The &lt;code&gt;handlePost2&lt;/code&gt; function no longer needs to check the method, and&#xA;extracting the identifier string can be written using the new &lt;code&gt;PathValue&lt;/code&gt; method&#xA;on &lt;code&gt;Request&lt;/code&gt;:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;idString := req.PathValue(&amp;quot;id&amp;quot;)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;The rest of &lt;code&gt;handlePost2&lt;/code&gt; would behave like &lt;code&gt;handlePost&lt;/code&gt;, converting the string&#xA;identifier to an integer and fetching the post.&lt;/p&gt;&#xA;&lt;p&gt;Requests like &lt;code&gt;DELETE /posts/234&lt;/code&gt; will fail if no other matching pattern is&#xA;registered. In accordance with &lt;a href=&#34;https://httpwg.org/specs/rfc9110.html#status.405&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;HTTP semantics&lt;/a&gt;, a &lt;code&gt;net/http&lt;/code&gt; server will reply&#xA;to such a request with a &lt;code&gt;405 Method Not Allowed&lt;/code&gt; error that lists the available methods&#xA;in an &lt;code&gt;Allow&lt;/code&gt; header.&lt;/p&gt;&#xA;&lt;p&gt;A wildcard can match an entire segment, like &lt;code&gt;{id}&lt;/code&gt; in the example above, or if&#xA;it ends in &lt;code&gt;...&lt;/code&gt; it can match all the remaining segments of the path, as in the&#xA;pattern &lt;code&gt;/files/{pathname...}&lt;/code&gt;.&lt;/p&gt;&#xA;&lt;p&gt;There is one last bit of syntax. As we showed above, patterns ending in a slash,&#xA;like &lt;code&gt;/posts/&lt;/code&gt;, match all paths beginning with that string. To match only the&#xA;path with the trailing slash, you can write &lt;code&gt;/posts/{$}&lt;/code&gt;. That will match&#xA;&lt;code&gt;/posts/&lt;/code&gt; but not &lt;code&gt;/posts&lt;/code&gt; or &lt;code&gt;/posts/234&lt;/code&gt;.&lt;/p&gt;&#xA;&lt;p&gt;And there is one last bit of API: &lt;code&gt;net/http.Request&lt;/code&gt; has a &lt;code&gt;SetPathValue&lt;/code&gt; method&#xA;so that routers outside the standard library can make the results of their own&#xA;path parsing available via &lt;code&gt;Request.PathValue&lt;/code&gt;.&lt;/p&gt;&#xA;&lt;h2 id=&#34;precedence&#34;&gt;Precedence&lt;/h2&gt;&#xA;&lt;p&gt;Every HTTP router must deal with overlapping patterns, like &lt;code&gt;/posts/{id}&lt;/code&gt; and&#xA;&lt;code&gt;/posts/latest&lt;/code&gt;. Both of these patterns match the path &amp;ldquo;posts/latest&amp;rdquo;, but at most&#xA;one can serve the request. Which pattern takes precedence?&lt;/p&gt;&#xA;&lt;p&gt;Some routers disallow overlaps; others use the pattern that was registered last.&#xA;Go has always allowed overlaps, and has chosen the longer pattern regardless&#xA;of registration order. Preserving order-independence was important to us (and&#xA;necessary for backwards compatibility), but we needed a better rule than&#xA;&amp;ldquo;longest wins.&amp;rdquo; That rule would select &lt;code&gt;/posts/latest&lt;/code&gt; over &lt;code&gt;/posts/{id}&lt;/code&gt;, but&#xA;would choose &lt;code&gt;/posts/{identifier}&lt;/code&gt; over both. That seems wrong: the wildcard&#xA;name shouldn&amp;rsquo;t matter. It feels like &lt;code&gt;/posts/latest&lt;/code&gt; should always win this&#xA;competition, because it matches a single path instead of many.&lt;/p&gt;&#xA;&lt;p&gt;Our quest for a good precedence rule led us to consider many properties of&#xA;patterns. For example, we considered preferring the pattern with the longest&#xA;literal (non-wildcard) prefix. That would choose &lt;code&gt;/posts/latest&lt;/code&gt; over &lt;code&gt;/posts/ {id}&lt;/code&gt;. But it wouldn&amp;rsquo;t distinguish between &lt;code&gt;/users/{u}/posts/latest&lt;/code&gt; and&#xA;&lt;code&gt;/users/{u}/posts/{id}&lt;/code&gt;, and it seems like the former should take precedence.&lt;/p&gt;&#xA;&lt;p&gt;We eventually chose a rule based on what the patterns mean instead of how they&#xA;look. Every valid pattern matches a set of requests. For example,&#xA;&lt;code&gt;/posts/latest&lt;/code&gt; matches requests with the path &lt;code&gt;/posts/latest&lt;/code&gt;, while &lt;code&gt;/posts/{id}&lt;/code&gt;&#xA;matches requests with any two-segment path whose first segment is &amp;ldquo;posts&amp;rdquo;. We&#xA;say that one pattern is &lt;em&gt;more specific&lt;/em&gt; than another if it matches a strict subset&#xA;of requests. The pattern &lt;code&gt;/posts/latest&lt;/code&gt; is more specific than &lt;code&gt;/posts/{id}&lt;/code&gt;&#xA;because the latter matches every request that the former does, and more.&lt;/p&gt;&#xA;&lt;p&gt;The precedence rule is simple: the most specific pattern wins. This rule&#xA;matches our intuition that &lt;code&gt;posts/latests&lt;/code&gt; should be preferred to &lt;code&gt;posts/{id}&lt;/code&gt;,&#xA;and &lt;code&gt;/users/{u}/posts/latest&lt;/code&gt; should be preferred to &lt;code&gt;/users/{u}/posts/{id}&lt;/code&gt;.&#xA;It also makes sense for methods. For example, &lt;code&gt;GET /posts/{id}&lt;/code&gt; takes&#xA;precedence over &lt;code&gt;/posts/{id}&lt;/code&gt; because the first only matches GET and HEAD&#xA;requests, while the second matches requests with any method.&lt;/p&gt;&#xA;&lt;p&gt;The &amp;ldquo;most specific wins&amp;rdquo; rule generalizes the original &amp;ldquo;longest wins&amp;rdquo; rule for&#xA;the path parts of original patterns, those without wildcards or &lt;code&gt;{$}&lt;/code&gt;. Such&#xA;patterns only overlap when one is a prefix of the other, and the longer is the&#xA;more specific.&lt;/p&gt;&#xA;&lt;p&gt;What if two patterns overlap but neither is more specific? For example, &lt;code&gt;/posts/{id}&lt;/code&gt;&#xA;and &lt;code&gt;/{resource}/latest&lt;/code&gt; both match &lt;code&gt;/posts/latest&lt;/code&gt;. There is no obvious answer to&#xA;which takes precedence, so we consider these patterns to conflict with each other.&#xA;Registering both of them (in either order!) will panic.&lt;/p&gt;&#xA;&lt;p&gt;The precedence rule works exactly as above for methods and paths, but we had to&#xA;make one exception for hosts to preserve compatibility: if two patterns would&#xA;otherwise conflict and one has a host while the other does not, then the pattern&#xA;with the host takes precedence.&lt;/p&gt;&#xA;&lt;p&gt;Students of computer science may recall the beautiful theory of regular&#xA;expressions and regular languages. Each regular expression picks out a regular&#xA;language, the set of strings matched by the expression. Some questions are&#xA;easier to pose and answer by talking about languages rather than expressions.&#xA;Our precedence rule was inspired by this theory. Indeed, each routing pattern&#xA;corresponds to a regular expression, and sets of matching requests play the role of&#xA;regular languages.&lt;/p&gt;&#xA;&lt;p&gt;Defining precedence by languages instead of expressions makes it easy to state&#xA;and understand. But there is a downside to having a rule based on potentially&#xA;infinite sets: it isn&amp;rsquo;t clear how to implement it efficiently. It turns out we&#xA;can determine whether two patterns conflict by walking them segment by segment.&#xA;Roughly speaking, if one pattern has a literal segment wherever the other has a&#xA;wildcard, it is more specific; but if literals align with wildcards in both&#xA;directions, the patterns conflict.&lt;/p&gt;&#xA;&lt;p&gt;As new patterns are registered on a &lt;code&gt;ServeMux&lt;/code&gt;, it checks for conflicts with previously&#xA;registered patterns. But checking every pair of patterns would take quadratic&#xA;time. We use an index to skip patterns that cannot conflict with a new pattern;&#xA;in practice, it works quite well. In any case, this check happens when&#xA;patterns are registered, usually at server startup. The time to match incoming&#xA;requests in Go 1.22 hasn&amp;rsquo;t changed much from previous versions.&lt;/p&gt;&#xA;&lt;h2 id=&#34;compatibility&#34;&gt;Compatibility&lt;/h2&gt;&#xA;&lt;p&gt;We made every effort to keep the new functionality compatible with older&#xA;versions of Go. The new pattern syntax is a superset of the old, and the new&#xA;precedence rule generalizes the old one. But there are a few edge cases. For&#xA;example, previous versions of Go accepted patterns with braces and treated&#xA;them literally, but Go 1.22 uses braces for wildcards. The GODEBUG setting&#xA;&lt;code&gt;httpmuxgo121&lt;/code&gt; restores the old behavior.&lt;/p&gt;&#xA;&lt;p&gt;For more details about these routing enhancements, see the &lt;a href=&#34;/pkg/net/http#ServeMux&#34;&gt;&lt;code&gt;net/http.ServeMux&lt;/code&gt;&#xA;documentation&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;    &lt;/div&gt;&#xA;&#xA;    &#xA;    &lt;div class=&#34;Article prevnext&#34;&gt;&#xA;    &#xA;    &#xA;      &#xA;    &#xA;      &#xA;        &lt;p&gt;&#xA;        &#xA;          &#xA;            &lt;b&gt;Next article: &lt;/b&gt;&lt;a href=&#34;/blog/generic-slice-functions&#34;&gt;Robust generic functions on slices&lt;/a&gt;&lt;br&gt;&#xA;          &#xA;        &#xA;        &#xA;          &#xA;            &lt;b&gt;Previous article: &lt;/b&gt;&lt;a href=&#34;/blog/go1.22&#34;&gt;Go 1.22 is released!&lt;/a&gt;&lt;br&gt;&#xA;          &#xA;        &#xA;        &lt;b&gt;&lt;a href=&#34;/blog/all&#34;&gt;Blog Index&lt;/a&gt;&lt;/b&gt;&#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;    &lt;/div&gt;&#xA;    &#xA;&#xA;  &lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;script src=&#34;/js/jquery.js&#34;&gt;&lt;/script&gt;&#xA;&lt;script src=&#34;/js/playground.js&#34;&gt;&lt;/script&gt;&#xA;&lt;script src=&#34;/js/play.js&#34;&gt;&lt;/script&gt;&#xA;&lt;script src=&#34;/js/godocs.js&#34;&gt;&lt;/script&gt;&#xA;&#xA;</content></entry><entry><title>Go 1.22 is released!</title><id>tag:blog.golang.org,2013:blog.golang.org/go1.22</id><link rel="alternate" href="https://go.dev/blog/go1.22"></link><published>2024-02-06T00:00:00+00:00</published><updated>2024-02-06T00:00:00+00:00</updated><author><name></name></author><summary type="html">Go 1.22 enhances for loops, brings new standard library functionality and improves performance.</summary><content type="html">&#xA;&lt;div id=&#34;blog&#34;&gt;&lt;div id=&#34;content&#34;&gt;&#xA;  &lt;div id=&#34;content&#34;&gt;&#xA;&#xA;    &lt;div class=&#34;Article&#34; data-slug=&#34;/blog/go1.22&#34;&gt;&#xA;    &#xA;    &lt;h1 class=&#34;small&#34;&gt;&lt;a href=&#34;/blog/&#34;&gt;The Go Blog&lt;/a&gt;&lt;/h1&gt;&#xA;    &#xA;&#xA;    &lt;h1&gt;Go 1.22 is released!&lt;/h1&gt;&#xA;      &#xA;      &lt;p class=&#34;author&#34;&gt;&#xA;      Eli Bendersky, on behalf of the Go team&lt;br&gt;&#xA;      6 February 2024&#xA;      &lt;/p&gt;&#xA;      &#xA;      &lt;p&gt;Today the Go team is thrilled to release Go 1.22,&#xA;which you can get by visiting the &lt;a href=&#34;/dl/&#34;&gt;download page&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;p&gt;Go 1.22 comes with several important new features and improvements. Here are&#xA;some of the notable changes; for the full list, refer to the &lt;a href=&#34;/doc/go1.22&#34;&gt;release&#xA;notes&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;h2 id=&#34;language-changes&#34;&gt;Language changes&lt;/h2&gt;&#xA;&lt;p&gt;The long-standing &amp;ldquo;for&amp;rdquo; loop gotcha with accidental sharing of loop variables&#xA;between iterations is now resolved. Starting with Go 1.22, the following code&#xA;will print &amp;ldquo;a&amp;rdquo;, &amp;ldquo;b&amp;rdquo;, and &amp;ldquo;c&amp;rdquo; in some order:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;func main() {&#xA;    done := make(chan bool)&#xA;&#xA;    values := []string{&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;}&#xA;    for _, v := range values {&#xA;        go func() {&#xA;            fmt.Println(v)&#xA;            done &amp;lt;- true&#xA;        }()&#xA;    }&#xA;&#xA;    // wait for all goroutines to complete before exiting&#xA;    for _ = range values {&#xA;        &amp;lt;-done&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;For more information about this change and the tooling that helps keep code from&#xA;breaking accidentally, see the earlier &lt;a href=&#34;/blog/loopvar-preview&#34;&gt;loop variable blog&#xA;post&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;p&gt;The second language change is support for ranging over integers:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;import &amp;quot;fmt&amp;quot;&#xA;&#xA;func main() {&#xA;    for i := range 10 {&#xA;        fmt.Println(10 - i)&#xA;    }&#xA;    fmt.Println(&amp;quot;go1.22 has lift-off!&amp;quot;)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;The values of &lt;code&gt;i&lt;/code&gt; in this countdown program go from 0 to 9, inclusive. For more&#xA;details, please refer to &lt;a href=&#34;/ref/spec#For_range&#34;&gt;the spec&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;h2 id=&#34;improved-performance&#34;&gt;Improved performance&lt;/h2&gt;&#xA;&lt;p&gt;Memory optimization in the Go runtime improves CPU performance by 1-3%, while&#xA;also reducing the memory overhead of most Go programs by around 1%.&lt;/p&gt;&#xA;&lt;p&gt;In Go 1.21, &lt;a href=&#34;/blog/pgo&#34;&gt;we shipped&lt;/a&gt; profile-guided optimization (PGO) for the Go&#xA;compiler and this functionality continues to improve. One of the optimizations&#xA;added in 1.22 is improved devirtualization, allowing static dispatch of more&#xA;interface method calls. Most programs will see improvements between 2-14% with&#xA;PGO enabled.&lt;/p&gt;&#xA;&lt;h2 id=&#34;standard-library-additions&#34;&gt;Standard library additions&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;A new &lt;a href=&#34;/pkg/math/rand/v2&#34;&gt;math/rand/v2&lt;/a&gt; package&#xA;provides a cleaner, more consistent API and uses higher-quality,&#xA;faster pseudo-random generation algorithms. See&#xA;&lt;a href=&#34;/issue/61716&#34;&gt;the proposal&lt;/a&gt; for additional details.&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;The patterns used by &lt;a href=&#34;/pkg/net/http#ServeMux&#34;&gt;net/http.ServeMux&lt;/a&gt;&#xA;now accept methods and wildcards.&lt;/p&gt;&#xA;&lt;p&gt;For example, the router accepts a pattern like &lt;code&gt;GET /task/{id}/&lt;/code&gt;, which&#xA;matches only &lt;code&gt;GET&lt;/code&gt; requests and captures the value of the &lt;code&gt;{id}&lt;/code&gt; segment&#xA;in a map that can be accessed through &lt;a href=&#34;/pkg/net/http#Request&#34;&gt;Request&lt;/a&gt; values.&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;A new &lt;code&gt;Null[T]&lt;/code&gt; type in &lt;a href=&#34;/pkg/database/sql&#34;&gt;database/sql&lt;/a&gt; provides&#xA;a way to scan nullable columns.&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;A &lt;code&gt;Concat&lt;/code&gt; function was added in package &lt;a href=&#34;/pkg/slices&#34;&gt;slices&lt;/a&gt;, to&#xA;concatenate multiple slices of any type.&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;Thanks to everyone who contributed to this release by writing code and&#xA;documentation, filing bugs, sharing feedback, and testing the release&#xA;candidates. Your efforts helped to ensure that Go 1.22 is as stable as possible.&#xA;As always, if you notice any problems, please &lt;a href=&#34;/issue/new&#34;&gt;file an issue&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;p&gt;Enjoy Go 1.22!&lt;/p&gt;&#xA;&#xA;    &lt;/div&gt;&#xA;&#xA;    &#xA;    &lt;div class=&#34;Article prevnext&#34;&gt;&#xA;    &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;        &lt;p&gt;&#xA;        &#xA;          &#xA;            &lt;b&gt;Next article: &lt;/b&gt;&lt;a href=&#34;/blog/routing-enhancements&#34;&gt;Routing Enhancements for Go 1.22&lt;/a&gt;&lt;br&gt;&#xA;          &#xA;        &#xA;        &#xA;          &#xA;            &lt;b&gt;Previous article: &lt;/b&gt;&lt;a href=&#34;/blog/survey2024-h1&#34;&gt;Share your feedback about developing with Go&lt;/a&gt;&lt;br&gt;&#xA;          &#xA;        &#xA;        &lt;b&gt;&lt;a href=&#34;/blog/all&#34;&gt;Blog Index&lt;/a&gt;&lt;/b&gt;&#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;    &lt;/div&gt;&#xA;    &#xA;&#xA;  &lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;script src=&#34;/js/jquery.js&#34;&gt;&lt;/script&gt;&#xA;&lt;script src=&#34;/js/playground.js&#34;&gt;&lt;/script&gt;&#xA;&lt;script src=&#34;/js/play.js&#34;&gt;&lt;/script&gt;&#xA;&lt;script src=&#34;/js/godocs.js&#34;&gt;&lt;/script&gt;&#xA;&#xA;</content></entry><entry><title>Share your feedback about developing with Go</title><id>tag:blog.golang.org,2013:blog.golang.org/survey2024-h1</id><link rel="alternate" href="https://go.dev/blog/survey2024-h1"></link><published>2024-01-23T00:00:00+00:00</published><updated>2024-01-23T00:00:00+00:00</updated><author><name></name></author><summary type="html">Help shape the future of Go by sharing your thoughts via the Go Developer Survey</summary><content type="html">&#xA;&lt;div id=&#34;blog&#34;&gt;&lt;div id=&#34;content&#34;&gt;&#xA;  &lt;div id=&#34;content&#34;&gt;&#xA;&#xA;    &lt;div class=&#34;Article&#34; data-slug=&#34;/blog/survey2024-h1&#34;&gt;&#xA;    &#xA;    &lt;h1 class=&#34;small&#34;&gt;&lt;a href=&#34;/blog/&#34;&gt;The Go Blog&lt;/a&gt;&lt;/h1&gt;&#xA;    &#xA;&#xA;    &lt;h1&gt;Share your feedback about developing with Go&lt;/h1&gt;&#xA;      &#xA;      &lt;p class=&#34;author&#34;&gt;&#xA;      Alice Merrick, for the Go team&lt;br&gt;&#xA;      23 January 2024&#xA;      &lt;/p&gt;&#xA;      &#xA;      &lt;p&gt;Happy New Year! &lt;a href=&#34;https://google.qualtrics.com/jfe/form/SV_083SVAUCji98YeO?s=b&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;The Go Developer Survey is now&#xA;open&lt;/a&gt;, and we want&#xA;to hear from you!&lt;/p&gt;&#xA;&lt;p&gt;Since 2016, the insights from our Go Developer Surveys have helped us identify&#xA;key usage patterns, understand developer challenges, discover tooling&#xA;preferences, and track emerging trends within the community. Your feedback is&#xA;essential in shaping the future of Go, so please take 10–15 minutes to complete&#xA;the survey by February 11, 2024. &lt;a href=&#34;https://google.qualtrics.com/jfe/form/SV_083SVAUCji98YeO?s=b&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Take the survey&#xA;now!&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;The more developers who participate, the better we&amp;rsquo;ll be able to understand the&#xA;needs of the Go community. You can help spread the word by sharing this survey&#xA;on your social media channels, with your co-workers, and in any other relevant&#xA;communities.&lt;/p&gt;&#xA;&lt;p&gt;Thank you for your time and feedback!&lt;/p&gt;&#xA;&#xA;    &lt;/div&gt;&#xA;&#xA;    &#xA;    &lt;div class=&#34;Article prevnext&#34;&gt;&#xA;    &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;        &lt;p&gt;&#xA;        &#xA;          &#xA;            &lt;b&gt;Next article: &lt;/b&gt;&lt;a href=&#34;/blog/go1.22&#34;&gt;Go 1.22 is released!&lt;/a&gt;&lt;br&gt;&#xA;          &#xA;        &#xA;        &#xA;          &#xA;            &lt;b&gt;Previous article: &lt;/b&gt;&lt;a href=&#34;/blog/deadcode&#34;&gt;Finding unreachable functions with deadcode&lt;/a&gt;&lt;br&gt;&#xA;          &#xA;        &#xA;        &lt;b&gt;&lt;a href=&#34;/blog/all&#34;&gt;Blog Index&lt;/a&gt;&lt;/b&gt;&#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;    &lt;/div&gt;&#xA;    &#xA;&#xA;  &lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;script src=&#34;/js/jquery.js&#34;&gt;&lt;/script&gt;&#xA;&lt;script src=&#34;/js/playground.js&#34;&gt;&lt;/script&gt;&#xA;&lt;script src=&#34;/js/play.js&#34;&gt;&lt;/script&gt;&#xA;&lt;script src=&#34;/js/godocs.js&#34;&gt;&lt;/script&gt;&#xA;&#xA;</content></entry><entry><title>Finding unreachable functions with deadcode</title><id>tag:blog.golang.org,2013:blog.golang.org/deadcode</id><link rel="alternate" href="https://go.dev/blog/deadcode"></link><published>2023-12-12T00:00:00+00:00</published><updated>2023-12-12T00:00:00+00:00</updated><author><name></name></author><summary type="html">deadcode is a new command to help identify functions that cannot be called.</summary><content type="html">&#xA;&lt;div id=&#34;blog&#34;&gt;&lt;div id=&#34;content&#34;&gt;&#xA;  &lt;div id=&#34;content&#34;&gt;&#xA;&#xA;    &lt;div class=&#34;Article&#34; data-slug=&#34;/blog/deadcode&#34;&gt;&#xA;    &#xA;    &lt;h1 class=&#34;small&#34;&gt;&lt;a href=&#34;/blog/&#34;&gt;The Go Blog&lt;/a&gt;&lt;/h1&gt;&#xA;    &#xA;&#xA;    &lt;h1&gt;Finding unreachable functions with deadcode&lt;/h1&gt;&#xA;      &#xA;      &lt;p class=&#34;author&#34;&gt;&#xA;      Alan Donovan&lt;br&gt;&#xA;      12 December 2023&#xA;      &lt;/p&gt;&#xA;      &#xA;      &lt;p&gt;Functions that are part of your project&amp;rsquo;s source code but can never be&#xA;reached in any execution are called &amp;ldquo;dead code&amp;rdquo;, and they exert a drag&#xA;on codebase maintenance efforts.&#xA;Today we&amp;rsquo;re pleased to share a tool named &lt;code&gt;deadcode&lt;/code&gt; to help you identify them.&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;$ go install golang.org/x/tools/cmd/deadcode@latest&#xA;$ deadcode -help&#xA;The deadcode command reports unreachable functions in Go programs.&#xA;&#xA;Usage: deadcode [flags] package...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;example&#34;&gt;Example&lt;/h2&gt;&#xA;&lt;p&gt;Over the last year or so, we&amp;rsquo;ve been making a lot of changes to the&#xA;structure of &lt;a href=&#34;/blog/gopls-scalability&#34;&gt;gopls&lt;/a&gt;, the&#xA;language server for Go that powers VS Code and other editors.&#xA;A typical change might rewrite some existing function, taking care to&#xA;ensure that its new behavior satisfies the needs of all existing callers.&#xA;Sometimes, after putting in all that effort, we would discover to our&#xA;frustration that one of the callers was never actually reached in any&#xA;execution, so it could safely have been been deleted.&#xA;If we had known this beforehand our refactoring task would have been&#xA;easier.&lt;/p&gt;&#xA;&lt;p&gt;The simple Go program below illustrates the problem:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;module example.com/greet&#xA;go 1.21&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;import &amp;quot;fmt&amp;quot;&#xA;&#xA;func main() {&#xA;    var g Greeter&#xA;    g = Helloer{}&#xA;    g.Greet()&#xA;}&#xA;&#xA;type Greeter interface{ Greet() }&#xA;&#xA;type Helloer struct{}&#xA;type Goodbyer struct{}&#xA;&#xA;var _ Greeter = Helloer{}  // Helloer  implements Greeter&#xA;var _ Greeter = Goodbyer{} // Goodbyer implements Greeter&#xA;&#xA;func (Helloer) Greet()  { hello() }&#xA;func (Goodbyer) Greet() { goodbye() }&#xA;&#xA;func hello()   { fmt.Println(&amp;quot;hello&amp;quot;) }&#xA;func goodbye() { fmt.Println(&amp;quot;goodbye&amp;quot;) }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;When we execute it, it says hello:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;$ go run .&#xA;hello&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;It&amp;rsquo;s clear from its output that this program executes the &lt;code&gt;hello&lt;/code&gt;&#xA;function but not the &lt;code&gt;goodbye&lt;/code&gt; function.&#xA;What&amp;rsquo;s less clear at a glance is that the &lt;code&gt;goodbye&lt;/code&gt; function can&#xA;never be called.&#xA;However, we can&amp;rsquo;t simply delete &lt;code&gt;goodbye&lt;/code&gt;, because it&amp;rsquo;s required by the&#xA;&lt;code&gt;Goodbyer.Greet&lt;/code&gt; method, which in turn is required to implement the&#xA;&lt;code&gt;Greeter&lt;/code&gt; interface whose &lt;code&gt;Greet&lt;/code&gt; method we can see is called from &lt;code&gt;main&lt;/code&gt;.&#xA;But if we work forwards from main, we can see that no &lt;code&gt;Goodbyer&lt;/code&gt; values&#xA;are ever created, so the &lt;code&gt;Greet&lt;/code&gt; call in &lt;code&gt;main&lt;/code&gt; can only reach &lt;code&gt;Helloer.Greet&lt;/code&gt;.&#xA;That&amp;rsquo;s the idea behind the algorithm used by the &lt;code&gt;deadcode&lt;/code&gt; tool.&lt;/p&gt;&#xA;&lt;p&gt;When we run deadcode on this program, the tool tells us that the&#xA;&lt;code&gt;goodbye&lt;/code&gt; function and the &lt;code&gt;Goodbyer.Greet&lt;/code&gt; method are both unreachable:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;$ deadcode .&#xA;greet.go:23: unreachable func: goodbye&#xA;greet.go:20: unreachable func: Goodbyer.Greet&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;With this knowledge, we can safely remove both functions,&#xA;along with the &lt;code&gt;Goodbyer&lt;/code&gt; type itself.&lt;/p&gt;&#xA;&lt;p&gt;The tool can also explain why the &lt;code&gt;hello&lt;/code&gt; function is live. It responds&#xA;with a chain of function calls that reaches &lt;code&gt;hello&lt;/code&gt;, starting from main:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;$ deadcode -whylive=example.com/greet.hello .&#xA;                  example.com/greet.main&#xA;dynamic@L0008 --&amp;gt; example.com/greet.Helloer.Greet&#xA; static@L0019 --&amp;gt; example.com/greet.hello&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;The output is designed to be easy to read on a terminal, but you can&#xA;use the &lt;code&gt;-json&lt;/code&gt; or &lt;code&gt;-f=template&lt;/code&gt; flags to specify richer output formats for&#xA;consumption by other tools.&lt;/p&gt;&#xA;&lt;h2 id=&#34;how-it-works&#34;&gt;How it works&lt;/h2&gt;&#xA;&lt;p&gt;The &lt;code&gt;deadcode&lt;/code&gt; command&#xA;&lt;a href=&#34;https://pkg.go.dev/golang.org/x/tools/go/packages&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;loads&lt;/a&gt;,&#xA;&lt;a href=&#34;https://pkg.go.dev/go/parser&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;parses&lt;/a&gt;,&#xA;and &lt;a href=&#34;https://pkg.go.dev/go/types&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;type-checks&lt;/a&gt; the specified packages,&#xA;then converts them into an&#xA;&lt;a href=&#34;https://pkg.go.dev/golang.org/x/tools/go/ssa&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;intermediate representation&lt;/a&gt;&#xA;similar to a typical compiler.&lt;/p&gt;&#xA;&lt;p&gt;It then uses an algorithm called&#xA;&lt;a href=&#34;https://pkg.go.dev/golang.org/x/tools/go/callgraph/rta&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Rapid Type Analysis&lt;/a&gt; (RTA)&#xA;to build up the set of functions that are reachable,&#xA;which is initially just the entry points of each &lt;code&gt;main&lt;/code&gt; package:&#xA;the &lt;code&gt;main&lt;/code&gt; function,&#xA;and the package initializer function,&#xA;which assigns global variables and calls functions named &lt;code&gt;init&lt;/code&gt;.&lt;/p&gt;&#xA;&lt;p&gt;RTA looks at the statements in the body of each reachable function to&#xA;gather three kinds of information: the set of functions it calls directly;&#xA;the set of dynamic calls it makes through interface methods;&#xA;and the set of types it converts to an interface.&lt;/p&gt;&#xA;&lt;p&gt;Direct function calls are easy: we just add the callee to the set of&#xA;reachable functions, and if it&amp;rsquo;s the first time we&amp;rsquo;ve encountered the&#xA;callee, we inspect its function body the same way we did for main.&lt;/p&gt;&#xA;&lt;p&gt;Dynamic calls through interface methods are trickier, because we don&amp;rsquo;t&#xA;know the set of types that implement the interface. We don&amp;rsquo;t want&#xA;to assume that every possible method in the program whose type matches&#xA;is a possible target for the call, because some of those types may&#xA;be instantiated only from dead code! That&amp;rsquo;s why we gather the set of&#xA;types converted to interfaces: the conversion makes each of these&#xA;types reachable from &lt;code&gt;main&lt;/code&gt;, so that its methods are now possible&#xA;targets of dynamic calls.&lt;/p&gt;&#xA;&lt;p&gt;This leads to a chicken-and-egg situation. As we encounter each new&#xA;reachable function, we discover more interface method calls and more&#xA;conversions of concrete types to interface types.&#xA;But as the cross product of these two sets (interface method calls ×&#xA;concrete types) grows ever larger, we discover new reachable&#xA;functions.&#xA;This class of problems, called &amp;ldquo;dynamic programming&amp;rdquo;, can be solved by&#xA;(conceptually) making checkmarks in a large two-dimensional table,&#xA;adding rows and columns as we go, until there are no more checks to&#xA;add. The checkmarks in the final table tells us what is reachable;&#xA;the blank cells are the dead code.&lt;/p&gt;&#xA;&lt;div class=&#34;image&#34;&gt;&#xA;&lt;center&gt;&#xA;  &lt;img src=&#34;deadcode-rta.svg&#34; alt=&#34;illustration of Rapid Type Analysis&#34;/&gt;&lt;br/&gt;  &lt;i&gt;&#xA;   The &lt;code&gt;main&lt;/code&gt; function causes &lt;code&gt;Helloer&lt;/code&gt; to be&#xA;   instantiated, and the &lt;code&gt;g.Greet&lt;/code&gt; call&lt;br/&gt;&#xA;   dispatches to the &lt;code&gt;Greet&lt;/code&gt; method of each type instantiated so far.&#xA;  &lt;/i&gt;&#xA;&lt;/center&gt;&#xA;&lt;/div&gt;&#xA;&lt;p&gt;Dynamic calls to (non-method) functions are treated similar to&#xA;interfaces of a single method.&#xA;And calls made &lt;a href=&#34;https://pkg.go.dev/reflect#Value.Call&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;using reflection&lt;/a&gt;&#xA;are considered to reach any method of any type used in an interface&#xA;conversion, or any type derivable from one using the &lt;code&gt;reflect&lt;/code&gt; package.&#xA;But the principle is the same in all cases.&lt;/p&gt;&#xA;&lt;h2 id=&#34;tests&#34;&gt;Tests&lt;/h2&gt;&#xA;&lt;p&gt;RTA is a whole-program analysis. That means it always starts from a&#xA;main function and works forward: you can&amp;rsquo;t start from a library&#xA;package such as &lt;code&gt;encoding/json&lt;/code&gt;.&lt;/p&gt;&#xA;&lt;p&gt;However, most library packages have tests, and tests have main&#xA;functions. We don&amp;rsquo;t see them because they are generated behind the&#xA;scenes of &lt;code&gt;go test&lt;/code&gt;, but we can include them in the analysis using the&#xA;&lt;code&gt;-test&lt;/code&gt; flag.&lt;/p&gt;&#xA;&lt;p&gt;If this reports that a function in a library package is dead, that&amp;rsquo;s&#xA;a sign that your test coverage could be improved.&#xA;For example, this command lists all the functions in &lt;code&gt;encoding/json&lt;/code&gt;&#xA;that are not reached by any of its tests:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;$ deadcode -test -filter=encoding/json encoding/json&#xA;encoding/json/decode.go:150:31: unreachable func: UnmarshalFieldError.Error&#xA;encoding/json/encode.go:225:28: unreachable func: InvalidUTF8Error.Error&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;(The &lt;code&gt;-filter&lt;/code&gt; flag restricts the output to packages matching the&#xA;regular expression. By default, the tool reports all packages in the&#xA;initial module.)&lt;/p&gt;&#xA;&lt;h2 id=&#34;soundness&#34;&gt;Soundness&lt;/h2&gt;&#xA;&lt;p&gt;All static analysis tools&#xA;&lt;a href=&#34;https://en.wikipedia.org/wiki/Rice%27s_theorem&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;necessarily&lt;/a&gt;&#xA;produce imperfect approximations of the possible dynamic&#xA;behaviors of the target program.&#xA;A tool&amp;rsquo;s assumptions and inferences may be &amp;ldquo;sound&amp;rdquo;, meaning&#xA;conservative but perhaps overly cautious, or &amp;ldquo;unsound&amp;rdquo;, meaning&#xA;optimistic but not always correct.&lt;/p&gt;&#xA;&lt;p&gt;The deadcode tool is no exception: it must approximate the set of&#xA;targets of dynamic calls through function and interface values or&#xA;using reflection.&#xA;In this respect, the tool is sound. In other words, if it reports a&#xA;function as dead code, it means the function cannot be called even&#xA;through these dynamic mechanisms. However the tool may fail to report&#xA;some functions that in fact can never be executed.&lt;/p&gt;&#xA;&lt;p&gt;The deadcode tool must also approximate the set of calls made from&#xA;functions not written in Go, which it cannot see.&#xA;In this respect, the tool is not sound.&#xA;Its analysis is not aware of functions called exclusively from&#xA;assembly code, or of the aliasing of functions that arises from&#xA;the &lt;a href=&#34;https://pkg.go.dev/cmd/compile#hdr-Compiler_Directives&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;go:linkname&lt;/code&gt; directive&lt;/a&gt;.&#xA;Fortunately both of these features are rarely used outside the Go runtime.&lt;/p&gt;&#xA;&lt;h2 id=&#34;try-it-out&#34;&gt;Try it out&lt;/h2&gt;&#xA;&lt;p&gt;We run &lt;code&gt;deadcode&lt;/code&gt; periodically on our projects, especially after&#xA;refactoring work, to help identify parts of the program that are no&#xA;longer needed.&lt;/p&gt;&#xA;&lt;p&gt;With the dead code laid to rest, you can focus on eliminating code&#xA;whose time has come to an end but that stubbornly remains alive,&#xA;continuing to drain your life force. We call such undead functions&#xA;&amp;ldquo;vampire code&amp;rdquo;!&lt;/p&gt;&#xA;&lt;p&gt;Please try it out:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;$ go install golang.org/x/tools/cmd/deadcode@latest&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;We&amp;rsquo;ve found it useful, and we hope you do too.&lt;/p&gt;&#xA;&#xA;    &lt;/div&gt;&#xA;&#xA;    &#xA;    &lt;div class=&#34;Article prevnext&#34;&gt;&#xA;    &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;        &lt;p&gt;&#xA;        &#xA;          &#xA;            &lt;b&gt;Next article: &lt;/b&gt;&lt;a href=&#34;/blog/survey2024-h1&#34;&gt;Share your feedback about developing with Go&lt;/a&gt;&lt;br&gt;&#xA;          &#xA;        &#xA;        &#xA;          &#xA;            &lt;b&gt;Previous article: &lt;/b&gt;&lt;a href=&#34;/blog/survey2023-h2-results&#34;&gt;Go Developer Survey 2023 H2 Results&lt;/a&gt;&lt;br&gt;&#xA;          &#xA;        &#xA;        &lt;b&gt;&lt;a href=&#34;/blog/all&#34;&gt;Blog Index&lt;/a&gt;&lt;/b&gt;&#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;    &lt;/div&gt;&#xA;    &#xA;&#xA;  &lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;script src=&#34;/js/jquery.js&#34;&gt;&lt;/script&gt;&#xA;&lt;script src=&#34;/js/playground.js&#34;&gt;&lt;/script&gt;&#xA;&lt;script src=&#34;/js/play.js&#34;&gt;&lt;/script&gt;&#xA;&lt;script src=&#34;/js/godocs.js&#34;&gt;&lt;/script&gt;&#xA;&#xA;</content></entry><entry><title>Go Developer Survey 2023 H2 Results</title><id>tag:blog.golang.org,2013:blog.golang.org/survey2023-h2-results</id><link rel="alternate" href="https://go.dev/blog/survey2023-h2-results"></link><published>2023-12-05T00:00:00+00:00</published><updated>2023-12-05T00:00:00+00:00</updated><author><name></name></author><summary type="html">What we learned from our 2023 H2 developer survey</summary><content type="html">&#xA;&lt;div id=&#34;blog&#34;&gt;&lt;div id=&#34;content&#34;&gt;&#xA;  &lt;div id=&#34;content&#34;&gt;&#xA;&#xA;    &lt;div class=&#34;Article&#34; data-slug=&#34;/blog/survey2023-h2-results&#34;&gt;&#xA;    &#xA;    &lt;h1 class=&#34;small&#34;&gt;&lt;a href=&#34;/blog/&#34;&gt;The Go Blog&lt;/a&gt;&lt;/h1&gt;&#xA;    &#xA;&#xA;    &lt;h1&gt;Go Developer Survey 2023 H2 Results&lt;/h1&gt;&#xA;      &#xA;      &lt;p class=&#34;author&#34;&gt;&#xA;      Todd Kulesza&lt;br&gt;&#xA;      5 December 2023&#xA;      &lt;/p&gt;&#xA;      &#xA;      &lt;style type=&#34;text/css&#34; scoped&gt;&#xA;  .chart {&#xA;    margin-left: 1.5rem;&#xA;    margin-right: 1.5rem;&#xA;    width: 800px;&#xA;  }&#xA;  blockquote p {&#xA;    color: var(--color-text-subtle) !important;&#xA;  }&#xA;&#xA;  .quote_source {&#xA;    font-style: italic;&#xA;  }&#xA;&#xA;  @media (prefers-color-scheme: dark) {&#xA;    .chart {&#xA;      border-radius: 8px;&#xA;    }&#xA;  }&#xA;&lt;/style&gt;&#xA;&lt;h2 id=&#34;background&#34;&gt;Background&lt;/h2&gt;&#xA;&lt;p&gt;In August 2023, the Go team at Google conducted our bi-annual survey of Go&#xA;developers. We recruited participants via a public post on the Go blog and a&#xA;randomized prompt in VS Code, resulting in 4,005 responses. We primarily&#xA;focused survey questions around a few topics: general sentiment and feedback&#xA;about developing with Go, technology stacks used alongside Go, how developers&#xA;start new Go projects, recent experiences with toolchain error messages, and&#xA;understanding developer interest around ML/AI.&lt;/p&gt;&#xA;&lt;p&gt;Thank you to everyone who participated in this survey! This report shares what&#xA;we learned from your feedback.&lt;/p&gt;&#xA;&lt;h2 id=&#34;tldr&#34;&gt;tl;dr&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Go developers said they are &lt;strong&gt;more interested in AI/ML tooling that&#xA;improves the quality, reliability, and performance of code they write&lt;/strong&gt;,&#xA;rather than writing code for them. An always-awake, never-busy expert&#xA;&amp;ldquo;reviewer&amp;rdquo; might be one of the more helpful forms of AI developer&#xA;assistance.&lt;/li&gt;&#xA;&lt;li&gt;The top requests for improving toolchain warnings and errors were to &lt;strong&gt;make&#xA;the messages more comprehensible and actionable&lt;/strong&gt;; this sentiment was&#xA;shared by developers of all experience levels, but was particularly strong&#xA;among newer Go developers.&lt;/li&gt;&#xA;&lt;li&gt;Our experiment with project templates (&lt;code&gt;gonew&lt;/code&gt;) appears to solve critical&#xA;problems for Go developers (especially developers new to Go) and does so in&#xA;a way that matches their existing workflows for starting a new project.&#xA;Based on these findings, we believe &lt;strong&gt;&lt;code&gt;gonew&lt;/code&gt; can substantially reduce&#xA;onboarding barriers for new Go developers and ease adoption of Go in&#xA;organizations&lt;/strong&gt;.&lt;/li&gt;&#xA;&lt;li&gt;Three out of every four respondents work on Go software that also uses&#xA;cloud services; this is evidence that &lt;strong&gt;developers see Go as a language for&#xA;modern, cloud-based development&lt;/strong&gt;.&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Developer sentiment towards Go remains extremely positive&lt;/strong&gt;, with 90% of&#xA;survey respondents saying they felt satisfied while working with Go during&#xA;the prior year.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;contents&#34;&gt;Contents&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#sentiment&#34;&gt;Developer sentiment&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#devenv&#34;&gt;Developer environments&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#stacks&#34;&gt;Tech stacks&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#gonew&#34;&gt;How developers start new Go projects&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#err_handling&#34;&gt;Developer goals for error handling&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#mlai&#34;&gt;Understanding ML/AI use cases&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#err_msgs&#34;&gt;Toolchain error messages&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#microservices&#34;&gt;Microservices&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#modules&#34;&gt;Module authorship and maintenance&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#demographics&#34;&gt;Demographics&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#firmographics&#34;&gt;Firmographics&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#methodology&#34;&gt;Methodology&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#closing&#34;&gt;Closing&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;sentiment&#34;&gt;Developer sentiment&lt;/h2&gt;&#xA;&lt;p&gt;Go developers continue to report high levels of satisfaction with the Go&#xA;ecosystem. A large majority of respondents said they felt satisfied while&#xA;working with Go over the past year (90% satisfied, 6% dissatisfied), and a&#xA;majority (52%) went further and said they were &amp;ldquo;very satisfied&amp;rdquo;, the highest&#xA;rating. Longtime readers have likely noticed that this number doesn&amp;rsquo;t change&#xA;much from year to year. This is expected for a large, stable project like Go;&#xA;we view this metric as a &lt;a href=&#34;https://en.wikipedia.org/wiki/Economic_indicator#Lagging_indicators&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;lagging&#xA;indicator&lt;/a&gt;&#xA;that can help confirm widespread issues in the Go ecosystem, but isn&amp;rsquo;t where&#xA;we expect to first learn about potential problems.&lt;/p&gt;&#xA;&lt;p&gt;We typically find that the longer someone has worked with Go, the more likely&#xA;they are to report being satisfied with it. This trend continued in 2023;&#xA;among respondents with less than one year of Go experience, 82% reported&#xA;satisfaction with the Go development experience, compared to the 94% of Go&#xA;developers with five or more years of experience. There are likely a mix of&#xA;factors contributing to this, such as some respondents developing an&#xA;appreciation for Go&amp;rsquo;s design choices over time, or deciding Go isn&amp;rsquo;t a good&#xA;fit for their work and so not returning to this survey in following years&#xA;(i.e., &lt;a href=&#34;https://en.wikipedia.org/wiki/Survivorship_bias&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;survivorship bias&lt;/a&gt;).&#xA;Still, this data helps us quantify the current getting started experience for&#xA;Go developers, and it seems clear we could do more to help emerging Gophers&#xA;find their footing and enjoy early successes developing with Go.&lt;/p&gt;&#xA;&lt;p&gt;The key takeaway is that a large majority of people who chose to work with Go&#xA;during the past year were happy with their experience. Further, the number of&#xA;people working with Go continues to increase; we see evidence of this from&#xA;external research like &lt;a href=&#34;https://survey.stackoverflow.co/2023/#most-popular-technologies-language-prof&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Stack Overflow&amp;rsquo;s Developer&#xA;Survey&lt;/a&gt;&#xA;(which found 14% of professional developers worked with Go during the past&#xA;year, a roughly 15% year-over-year increase), as well as analytics for&#xA;&lt;a href=&#34;/&#34;&gt;go.dev&lt;/a&gt; (which show an 8% rise in visitors year-over-year).&#xA;Combining this growth with a high satisfaction score is evidence that Go&#xA;continues to appeal to developers, and suggests that many developers who&#xA;choose to learn the language feel good about their decision long afterwards.&#xA;In their own words:&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&amp;ldquo;After 30+ years of development in C, C++, Java, and now seven years of&#xA;programming in Go, it is still the most productive language by far. It&amp;rsquo;s not&#xA;perfect (no language is), but it has the best balance of productivity,&#xA;complexity, and performance.&amp;rdquo; &lt;span class=&#34;quote_source&#34;&gt;&amp;mdash; Professional Go&#xA;developer w/ 5 &amp;ndash; 9 years of experience&lt;/span&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&amp;ldquo;This is currently the best language I know, and I&amp;rsquo;ve tried many. The&#xA;tooling is awesome, compile times are great, and I can be really productive.&#xA;I&amp;rsquo;m glad I have Go as a tool, and I don&amp;rsquo;t need to use TypeScript&#xA;server-side. Thanks.&amp;rdquo; &lt;span class=&#34;quote_source&#34;&gt;&amp;mdash; Open source Go&#xA;developer w/ 3 &amp;ndash; 4 years of experience&lt;/span&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;&lt;img src=&#34;survey2023h2/csat.svg&#34; alt=&#34;Chart of developer satisfaction with Go&#34;&#xA;class=&#34;chart&#34; /&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;devenv&#34;&gt;Developer environments&lt;/h2&gt;&#xA;&lt;p&gt;As in prior years, the majority of survey respondents told us they work with&#xA;Go on Linux (63%) and macOS (58%) systems. Small variations in these numbers&#xA;from year to year are most likely dependent upon who finds and responds to&#xA;this survey (particularly on the Go blog), as we don&amp;rsquo;t see consistent&#xA;year-over-year trends in the random sample coming from VS Code.&lt;/p&gt;&#xA;&lt;p&gt;We do continue to see that newer members of the Go community are more likely&#xA;to be working with Windows than more experienced Go developers. We interpret&#xA;this as a signal that Windows-based development is important for onboarding&#xA;new developers to the Go ecosystem, and is a topic our team hopes to focus on&#xA;more in 2024.&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;survey2023h2/os_dev.svg&#34; alt=&#34;Chart of operating systems respondents&#xA;use when developing Go software&#34; class=&#34;chart&#34; /&gt; &lt;img&#xA;src=&#34;survey2023h2/os_dev_exp.svg&#34; alt=&#34;Chart of operating systems respondents&#xA;use when developing Go software, split by duration of experience&#34;&#xA;class=&#34;chart&#34; /&gt;&lt;/p&gt;&#xA;&lt;p&gt;Respondents continue to be heavily focused on Linux deployments. Given the&#xA;prevalence of Go for cloud development and containerized workloads, this is&#xA;not surprising but is still an important confirmation. We found few meaningful&#xA;differences based on factors such as organization size or experience level;&#xA;indeed, while novice Go developers appear more likely to &lt;em&gt;develop&lt;/em&gt; on Windows,&#xA;92% still &lt;em&gt;deploy&lt;/em&gt; to Linux systems. Perhaps the most interesting finding from&#xA;this breakdown is that more experienced Go developers said they deploy to a&#xA;wider variety of systems (most notably WebAssembly and IoT), though it&amp;rsquo;s&#xA;unclear if this is because such deployments are challenging for newer Go&#xA;developers or the result of experienced Go developers using Go in a broader&#xA;range of contexts. We also observed that both IoT and WebAssembly have&#xA;steadily increased in recent years, with each rising from 3% in 2021 to 6% and&#xA;5% in 2023, respectively.&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;survey2023h2/os_deploy.svg&#34; alt=&#34;Chart of platforms respondents&#xA;deploy Go software to&#34; class=&#34;chart&#34; /&gt;&lt;/p&gt;&#xA;&lt;p&gt;The computing architecture landscape has changed over the past few years, and&#xA;we see that reflected in the current architectures Go developers say they work&#xA;with. While x86-compatible systems still account for the majority of&#xA;development (89%), ARM64 is also now used by a majority of respondents (56%).&#xA;This adoption appears to be partly driven by Apple Silicon; macOS developers&#xA;are now more likely to say they develop for ARM64 than for x86-based&#xA;architectures (76% vs. 71%). However, Apple hardware isn&amp;rsquo;t the only factor&#xA;driving ARM64 adoption: among respondents who don&amp;rsquo;t develop on macOS at all,&#xA;29% still say they develop for ARM64.&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;survey2023h2/arch.svg&#34; alt=&#34;Chart of architectures respondents use&#xA;with Go&#34; class=&#34;chart&#34; /&gt;&lt;/p&gt;&#xA;&lt;p&gt;The most common code editors among Go Developer Survey respondents continue to&#xA;be &lt;a href=&#34;https://code.visualstudio.com/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;VS Code&lt;/a&gt; (44%) and&#xA;&lt;a href=&#34;https://www.jetbrains.com/go/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;GoLand&lt;/a&gt; (31%). Both of these proportions&#xA;ticked down slightly from 2023 H1 (46% and 33%, respectively), but remain&#xA;within this survey&amp;rsquo;s margin of error. Among the &amp;ldquo;Other&amp;rdquo; category,&#xA;&lt;a href=&#34;https://helix-editor.com/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Helix&lt;/a&gt; accounted for the majority of responses.&#xA;Similar to the results for operating systems above, we don&amp;rsquo;t believe this&#xA;represents a meaningful shift in code editor usage, but rather shows some of&#xA;the variability we expect to see in a community survey such as this. In&#xA;particular, we exclude the randomly sampled respondents from VS Code for this&#xA;question, as we know that group is heavily biased towards VS Code. However,&#xA;that has the side effect of making these results more susceptible to variation&#xA;each year.&lt;/p&gt;&#xA;&lt;p&gt;We also looked at respondents&amp;rsquo; level of satisfaction with Go based on the&#xA;editor they prefer using. After controlling for length of experience, we found&#xA;no differences: we don&amp;rsquo;t believe people enjoy working with Go more or less&#xA;based on which code editor they use. That doesn&amp;rsquo;t necessarily mean all Go&#xA;editors are equal, but may reflect that people find the editor that is best&#xA;for their own needs. This would suggest the Go ecosystem has a healthy&#xA;diversity of different editors geared towards different use cases and&#xA;developer preferences.&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;survey2023h2/editor_self_select.svg&#34; alt=&#34;Chart of code editors&#xA;respondents prefer to use with Go&#34; class=&#34;chart&#34; /&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;stacks&#34;&gt;Tech stacks&lt;/h2&gt;&#xA;&lt;p&gt;To better understand the web of software and services that Go developers&#xA;interact with, we asked several questions about tech stacks. We&amp;rsquo;re sharing&#xA;these results with the community to show which tools and platforms are in&#xA;common use today, but we believe everyone should consider their own needs and&#xA;use cases when selecting a tech stack. More plainly: we neither intend for&#xA;readers to use this data to select components of their tech stack because they&#xA;are popular, nor to avoid components because they are not commonly used.&lt;/p&gt;&#xA;&lt;p&gt;First, we can say with confidence that Go is a language for modern cloud-based&#xA;development. Indeed, 75% of respondents work on Go software that integrates&#xA;with cloud services. For nearly half of respondents, this involved AWS (48%),&#xA;and almost one-third used GCP (29%) for their Go development and deployments.&#xA;For both AWS and GCP, usage is equally balanced among large enterprises and&#xA;smaller organizations. Microsoft Azure is the only cloud provider that is&#xA;significantly more likely to be used in large organizations (companies with &amp;gt;&#xA;1,000 employees) than smaller shops; other providers show no meaningful&#xA;differences in usage based on the size of the organization.&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;survey2023h2/cloud.svg&#34; alt=&#34;Chart of cloud platforms respondents&#xA;use with Go&#34; class=&#34;chart&#34; /&gt;&lt;/p&gt;&#xA;&lt;p&gt;Databases are extremely common components of software systems, and we found&#xA;that 91% of respondents said the Go services they work on use at least one.&#xA;Most frequently this was PostgreSQL (59%), but with double digits of&#xA;respondents reporting use of six additional databases, it&amp;rsquo;s safe to say there&#xA;are not just a couple of standard DBs for Go developers to consider. We again&#xA;see differences based on organization size, with respondents from smaller&#xA;organizations more likely to report using PostgreSQL and Redis, while&#xA;developers from large organizations are somewhat more likely to use a database&#xA;specific to their cloud provider.&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;survey2023h2/db.svg&#34; alt=&#34;Chart of databases respondents use with&#xA;Go&#34; class=&#34;chart&#34; /&gt;&lt;/p&gt;&#xA;&lt;p&gt;Another common component respondents reported using were caches or key-value&#xA;stores; 68% of respondents said they work on Go software incorporating at&#xA;least one of these. Redis was clearly the most common (57%), followed at a&#xA;distance by etcd (10%) and memcached (7%).&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;survey2023h2/cache.svg&#34; alt=&#34;Chart of caches respondents use with&#xA;Go&#34; class=&#34;chart&#34; /&gt;&lt;/p&gt;&#xA;&lt;p&gt;Similar to databases, survey respondents told us they use a range of different&#xA;observability systems. Prometheus and Grafana were the most commonly cited&#xA;(both at 43%), but Open Telemetry, Datadog, and Sentry were all in double&#xA;digits.&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;survey2023h2/metrics.svg&#34; alt=&#34;Chart of metric systems respondents&#xA;use with Go&#34; class=&#34;chart&#34; /&gt;&lt;/p&gt;&#xA;&lt;p&gt;Lest anyone wonder &amp;ldquo;Have we JSON&amp;rsquo;d all the things?&amp;rdquo;&amp;hellip; yes, yes we have.&#xA;Nearly every respondent (96%!) said their Go software uses the JSON data&#xA;format; that&amp;rsquo;s about as close to universal as you&amp;rsquo;ll see with self-reported&#xA;data. YAML, CSV, and protocol buffers are also all used by roughly half of&#xA;respondents, and double-digit proportions work with TOML and XML as well.&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;survey2023h2/data.svg&#34; alt=&#34;Chart of data formats respondents use&#xA;with Go&#34; class=&#34;chart&#34; /&gt;&lt;/p&gt;&#xA;&lt;p&gt;For authentication and authorization services, we found most respondents are&#xA;building upon the foundations provided by standards such as&#xA;&lt;a href=&#34;https://jwt.io/introduction&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;JWT&lt;/a&gt; and &lt;a href=&#34;https://oauth.net/2/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;OAuth2&lt;/a&gt;. This&#xA;also appears to be an area where an organization&amp;rsquo;s cloud provider&amp;rsquo;s solution&#xA;is about as likely to be used as most turn-key alternatives.&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;survey2023h2/auth.svg&#34; alt=&#34;Chart of authentication systems&#xA;respondents use with Go&#34; class=&#34;chart&#34; /&gt;&lt;/p&gt;&#xA;&lt;p&gt;Finally, we have a bit of a grab bag of other services that don&amp;rsquo;t neatly fit&#xA;into the above categories. We found that nearly half of respondents work with&#xA;gRPC in their Go software (47%). For infrastructure-as-code needs, Terraform&#xA;was the tool of choice for about ¼ of respondents. Other fairly common&#xA;technologies used alongside Go included Apache Kafka, ElasticSearch, GraphQL,&#xA;and RabbitMQ.&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;survey2023h2/other_tech.svg&#34; alt=&#34;Chart of authentication systems&#xA;respondents use with Go&#34; class=&#34;chart&#34; /&gt;&lt;/p&gt;&#xA;&lt;p&gt;We also looked at which technologies tended to be used together. While nothing&#xA;clearly analogous to the classic &lt;a href=&#34;https://en.wikipedia.org/wiki/LAMP_(software_bundle)&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;LAMP&#xA;stack&lt;/a&gt; emerged from this&#xA;analysis, we did identify some interesting patterns:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;All or nothing: Every category (except data formats) showed a strong&#xA;correlation where if a respondent answered “None” to one category, they&#xA;likely answered “None” for all of the others. We interpret this as evidence&#xA;that a minority of use cases require none of these tech stack components,&#xA;but once the use case requires any one of them, it likely requires (or is at&#xA;least simplified by) more than just one.&lt;/li&gt;&#xA;&lt;li&gt;A bias towards cross-platform technologies: Provider-specific solutions&#xA;(i.e., services that are unique to a single cloud platform) were not&#xA;commonly adopted. However, if respondents used one provider-specific&#xA;solution (e.g., for metrics), they were substantially more likely to also&#xA;say they used cloud-specific solutions in order areas (e.g., databases,&#xA;authentication, caching, etc.).&lt;/li&gt;&#xA;&lt;li&gt;Multicloud: The three biggest cloud platforms were most likely to be&#xA;involved in multicloud setups. For example, if an organization is using any&#xA;non-AWS cloud provider, they’re probably also using AWS. This pattern was&#xA;clearest for Amazon Web Services, but was also apparent (to a lesser extent)&#xA;for Google Cloud Platform and Microsoft Azure.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;gonew&#34;&gt;How developers start new Go projects&lt;/h2&gt;&#xA;&lt;p&gt;As part of our &lt;a href=&#34;/blog/gonew&#34;&gt;experimentation with project&#xA;templates&lt;/a&gt;, we wanted to understand how Go&#xA;developers get started with new projects today. Respondents told us their&#xA;biggest challenges were choosing an appropriate way to structure their project&#xA;(54%) and learning how to write idiomatic Go (47%). As two respondents phrased&#xA;it:&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&amp;ldquo;Finding an appropriate structure and the right abstraction levels for a new&#xA;project can be quite tedious; looking at high-profile community and&#xA;enterprise projects for inspiration can be quite confusing as everyone&#xA;structures their project differently&amp;rdquo; &lt;span class=&#34;quote_source&#34;&gt;&amp;mdash;&#xA;Professional Go developer w/ 5 &amp;ndash; 9 years of Go experience&lt;/span&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&amp;ldquo;It would be great if [Go had a] toolchain to create [a project&amp;rsquo;s] basic&#xA;structure for web or CLI like `go init &amp;lt;project name&amp;gt;`&amp;rdquo; &lt;span&#xA;class=&#34;quote_source&#34;&gt;&amp;mdash; Professional Go developer w/ 3 &amp;ndash; 4 years of&#xA;experience&lt;/span&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;Newer Go developers were even more likely to encounter these challenges: the&#xA;proportions increased to 59% and 53% for respondents with less than two years&#xA;of experience with Go, respectively. These are both areas we hope to improve&#xA;via our &lt;code&gt;gonew&lt;/code&gt; prototype: templates can provide new Go developers with&#xA;well-tested project structures and design patterns, with initial&#xA;implementations written in idiomatic Go. These survey results have helped our&#xA;team to keep the purpose of &lt;code&gt;gonew&lt;/code&gt; focused on tasks the Go community most&#xA;struggle with.&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;survey2023h2/new_challenge.svg&#34; alt=&#34;Chart of challenges respondents&#xA;faced when starting new Go projects&#34; class=&#34;chart&#34; /&gt;&lt;/p&gt;&#xA;&lt;p&gt;A majority of respondents told us they either use templates or copy+paste code&#xA;from existing projects when starting a new Go project (58%). Among respondents&#xA;with less than five years of Go experience, this proportion increased to&#xA;nearly ⅔ (63%). This was an important confirmation that the template-based&#xA;approach in &lt;code&gt;gonew&lt;/code&gt; seems to meet developers where they already are, aligning&#xA;a common, informal approach with &lt;code&gt;go&lt;/code&gt; command-style tooling. This is further&#xA;supported by the common feature requests for project templates: a majority of&#xA;respondents requested 1) a pre-configured directory structure to organize&#xA;their project and 2) sample code for common tasks in the project domain. These&#xA;results are well-aligned with the challenges developers said they faced in the&#xA;previous section. The responses to this question also help tease apart the&#xA;difference between project structure and design patterns, with nearly twice as&#xA;many respondents saying they want Go project templates to provide the former&#xA;than the latter.&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;survey2023h2/new_approach.svg&#34; alt=&#34;Chart of approaches respondents&#xA;used when starting new Go projects&#34; class=&#34;chart&#34; /&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;survey2023h2/templates.svg&#34; alt=&#34;Chart of functionality respondents&#xA;requested when starting new Go projects&#34; class=&#34;chart&#34; /&gt;&lt;/p&gt;&#xA;&lt;p&gt;A majority of respondents told us the ability to make changes to a template&#xA;&lt;em&gt;and&lt;/em&gt; have those changes propagate to projects based on that template was of&#xA;at least moderate importance. Anecdotally, we haven&amp;rsquo;t spoken with any&#xA;developers who &lt;em&gt;currently&lt;/em&gt; have this functionality with home-grown template&#xA;approaches, but it suggests this is an interesting avenue for future&#xA;development.&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;survey2023h2/template_updates.svg&#34; alt=&#34;Chart of respondent interest&#xA;in updatable templates&#34; class=&#34;chart&#34; /&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;err_handling&#34;&gt;Developer goals for error handling&lt;/h2&gt;&#xA;&lt;p&gt;A perennial topic of discussion among Go developers is potential improvements&#xA;to error handling. As one respondent summarized:&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&amp;ldquo;Error handling adds too much boilerplate (I know, you probably heard this&#xA;before)&amp;rdquo; &lt;span class=&#34;quote_source&#34;&gt;&amp;mdash; Open source Go developer w/ 1 &amp;ndash; 2&#xA;years of experience&lt;/span&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;But, we also hear from numerous developers that they appreciate Go&amp;rsquo;s approach&#xA;to error handling:&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&amp;ldquo;Go error handling is simple and effective. As I have backends in Java and&#xA;C# and exploring Rust and Zig now, I am always pleased to go back to write&#xA;Go code. And one of the reasons is, believe it or not, error handling. It is&#xA;really simple, plain and effective. Please leave it that way.&amp;rdquo; &lt;span&#xA;class=&#34;quote_source&#34;&gt;&amp;mdash; Open source Go developer w/ 5 &amp;ndash; 9 years of&#xA;experience&lt;/span&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;Rather than ask about specific modifications to error handling in Go, we&#xA;wanted to better understand developers&amp;rsquo; higher-level goals and whether Go&amp;rsquo;s&#xA;current approach has proven useful and usable. We found that a majority of&#xA;respondents appreciate Go&amp;rsquo;s approach to error handling (55%) and say it helps&#xA;them know when to check for errors (50%). Both of these outcomes were stronger&#xA;for respondents with more Go experience, suggesting that either developers&#xA;grow to appreciate Go&amp;rsquo;s approach to error handling over time, or that this is&#xA;one factor leading developers to eventually leave the Go ecosystem (or at&#xA;least stop responding to Go-related surveys). Many survey respondents also&#xA;felt that Go requires a lot of tedious, boilerplate code to check for errors&#xA;(43%); this remained true regardless of how much prior Go experience&#xA;respondents had. Interestingly, when respondents said they appreciate Go&amp;rsquo;s&#xA;error handling, they were unlikely to say it also results in lots of&#xA;boilerplate code&amp;mdash;our team had a hypothesis that Go developers can both&#xA;appreciate the language&amp;rsquo;s approach to error handling and feel it&amp;rsquo;s too&#xA;verbose, but only 14% of respondents agreed with both statements.&lt;/p&gt;&#xA;&lt;p&gt;Specific issues that respondents cited include challenges knowing which error&#xA;types to check for (28%), wanting to easily show a stack trace along with the&#xA;error message (28%), and the ease with which errors can be entirely ignored&#xA;(19%). About ⅓ of respondents were also interested in adopting concepts from&#xA;other languages, such as Rust&amp;rsquo;s &lt;code&gt;?&lt;/code&gt; operator (31%).&lt;/p&gt;&#xA;&lt;p&gt;The Go team has no plans to add exceptions to the language, but since this is&#xA;anecdotally a common request, we included it as a response choice. Only 1 in&#xA;10 respondents said they wished they could use exceptions in Go, and this was&#xA;inversely related to experience&amp;mdash;more veteran Go developers were less likely&#xA;to be interested in exceptions than respondents newer to the Go community.&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;survey2023h2/error_handling.svg&#34; alt=&#34;Chart of respondents&#39; thoughts&#xA;about Go&#39;s error handling approach&#34; class=&#34;chart&#34; /&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;mlai&#34;&gt;Understanding ML/AI use cases&lt;/h2&gt;&#xA;&lt;p&gt;The Go team is considering how the unfolding landscape of new ML/AI&#xA;technologies may impact software development in two distinct veins: 1) how&#xA;might ML/AI tooling help engineers write better software, and 2) how might Go&#xA;help engineers bring ML/AI support to their applications and services? Below,&#xA;we delve into each of these areas.&lt;/p&gt;&#xA;&lt;h3 id=&#34;helping-engineers-write-better-software&#34;&gt;Helping engineers write better software&lt;/h3&gt;&#xA;&lt;p&gt;There&amp;rsquo;s little denying we&amp;rsquo;re in &lt;a href=&#34;https://www.gartner.com/en/articles/what-s-new-in-artificial-intelligence-from-the-2023-gartner-hype-cycle&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;a hype cycle around the possibilities for&#xA;AI/ML&lt;/a&gt;.&#xA;We wanted to take a step back to focus on the broader challenges developers&#xA;face and where they think AI might prove useful in their regular work. The&#xA;answers were a bit surprising, especially given the industry&amp;rsquo;s current focus&#xA;on coding assistants.&lt;/p&gt;&#xA;&lt;p&gt;First, we see a few AI use cases that about half of respondents thought could&#xA;be helpful: generating tests (49%), suggesting best practices in-situ (47%),&#xA;and catching likely mistakes early in the development process (46%). A&#xA;unifying theme of these top use cases is that each could help improve the&#xA;quality and reliability of code an engineer is writing. A fourth use case&#xA;(help writing documentation) garnered interest from about ⅓ of respondents.&#xA;The remaining cases comprise a long tail of potentially fruitful ideas, but&#xA;these are of significantly less general interest than the top four.&lt;/p&gt;&#xA;&lt;p&gt;When we look at developers&amp;rsquo; duration of experience with Go, we find that&#xA;novice respondents are interested in help resolving compiler errors and&#xA;explaining what a piece of Go code does more than veteran Go developers. These&#xA;might be areas where AI could help improve the getting started experience for&#xA;new Gophers; for example, an AI assistant could help explain in natural&#xA;language what an undocumented block of code does, or suggest common solutions&#xA;to specific error messages. Conversely, we see no differences between&#xA;experience levels for topics like &amp;ldquo;catch common mistakes&amp;rdquo;&amp;mdash;both novice and&#xA;veteran Go developers say they would appreciate tooling to help with this.&lt;/p&gt;&#xA;&lt;p&gt;One can squint at this data and see three broad trends:&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Respondents voiced interest in getting feedback from &amp;ldquo;expert reviewers&amp;rdquo; in&#xA;real-time, not just during review time.&lt;/li&gt;&#xA;&lt;li&gt;Generally, respondents appeared most interested in tooling that saves them&#xA;from potentially less-enjoyable tasks (e.g., writing tests or documenting&#xA;code).&lt;/li&gt;&#xA;&lt;li&gt;Wholesale writing or translating of code was of fairly low interest,&#xA;especially to developers with more than a year or two of experience.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;Taken together, it appears that today, developers are less excited by the&#xA;prospect of machines doing the fun (e.g., creative, enjoyable, appropriately&#xA;challenging) parts of software development, but do see value in another set of&#xA;&amp;ldquo;eyes&amp;rdquo; reviewing their code and potentially handling dull or repetitive tasks&#xA;for them. As one respondent phrased it:&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&amp;ldquo;I&amp;rsquo;m specifically interested in using AI/ML to improve my productivity with&#xA;Go. Having a system that is trained in Go best practices, can catch&#xA;anti-patterns, bugs, generate tests, with a low rate of hallucination, would&#xA;be killer.&amp;rdquo; &lt;span class=&#34;quote_source&#34;&gt;&amp;mdash; Professional Go developer w/ 5 &amp;ndash;&#xA;9 years of experience&lt;/span&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;This survey, however, is just one data point in a quickly-evolving research&#xA;field, so it&amp;rsquo;s best to keep these results in context.&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;survey2023h2/ml_use_cases.svg&#34; alt=&#34;Chart of respondents&#39; interest&#xA;in AI/ML support for development tasks&#34; class=&#34;chart&#34; /&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;bringing-ai-features-to-applications-and-services&#34;&gt;Bringing AI features to applications and services&lt;/h3&gt;&#xA;&lt;p&gt;In addition to looking at how Go developers might benefit from AI/ML-powered&#xA;tooling, we explored their plans for building AI-powered applications and&#xA;services (or supporting infrastructure) with Go. We found that we&amp;rsquo;re still&#xA;early in &lt;a href=&#34;https://en.wikipedia.org/wiki/Technology_adoption_life_cycle&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;the adoption&#xA;curve&lt;/a&gt;: most&#xA;respondents have not yet tried to use Go in these areas, though every topic&#xA;saw some level of interest from roughly half of respondents. For example, a&#xA;majority of respondents reported interest in integrating the Go services they&#xA;work on with LLMs (49%), but only 13% have already done so or are currently&#xA;evaluating this use case. At the time of this survey, responses gently suggest&#xA;that developers may be most interested in using Go to call LLMs directly,&#xA;build the data pipelines needed to power ML/AI systems, and for creating API&#xA;endpoints other services can call to interact with ML/AI models. As one&#xA;example, this respondent described the benefits they hoped to gain by using Go&#xA;in their data pipelines:&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&amp;ldquo;I want to integrate the ETL [extract, transform, and load] part using Go,&#xA;to keep a consistent, robust, reliable codebase.&amp;rdquo; &lt;span&#xA;class=&#34;quote_source&#34;&gt;&amp;mdash; Professional Go developer w/ 3 &amp;ndash; 4 years of&#xA;experience&lt;/span&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;&lt;img src=&#34;survey2023h2/ml_adoption.svg&#34; alt=&#34;Chart of respondents&#39; current use&#xA;of (and interest in) Go for AI/ML systems&#34; class=&#34;chart&#34; /&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;err_msgs&#34;&gt;Toolchain error messages&lt;/h2&gt;&#xA;&lt;p&gt;Many developers can relate to the frustrating experience of seeing an error&#xA;message, thinking they know what it means and how to resolve it, but after&#xA;hours of fruitless debugging realize it meant something else entirely. One&#xA;respondent explained their frustration as follows:&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&amp;ldquo;So often the printed complaints wind up having nothing to do with the&#xA;problem, but it can take an hour before I discover that that&amp;rsquo;s the case. The&#xA;error messages are unnervingly terse, and don&amp;rsquo;t seem to go out of their way&#xA;to guess as to what the user might be trying to do or [explain what they&amp;rsquo;re]&#xA;doing wrong.&amp;rdquo; &lt;span class=&#34;quote_source&#34;&gt;&amp;mdash; Professional Go developer w/ 10+&#xA;years of experience&lt;/span&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;We believe the warnings and errors emitted by developer tooling should be&#xA;brief, understandable, and actionable: the human reading them should be able&#xA;to accurately understand what went wrong and what they can do to resolve the&#xA;issue. This is an admittedly high bar to strive for, and with this survey we&#xA;took some measurements to understand how developers perceive Go&amp;rsquo;s current&#xA;warning and error messages.&lt;/p&gt;&#xA;&lt;p&gt;When thinking about the most recent Go error message they worked through,&#xA;respondents told us there was much room for improvement. Only a small majority&#xA;understood what the problem was from the error message alone (54%), and even&#xA;fewer knew what to do next to resolve the issue (41%). It appears a relatively&#xA;small amount of additional information could meaningfully increase these&#xA;proportions, as ¼ of respondents said they mostly knew how to fix the problem,&#xA;but needed to see an example first. Further, with 11% of respondents saying&#xA;they couldn&amp;rsquo;t make sense of the error message, we now have a baseline for&#xA;current understandability of the Go toolchain&amp;rsquo;s error messages.&lt;/p&gt;&#xA;&lt;p&gt;Improvements to Go&amp;rsquo;s toolchain error messages would especially benefit&#xA;less-experienced Gophers. Respondents with up to two years of experience were&#xA;less likely than veteran Gophers to say they understood the problem (47% vs.&#xA;61%) or knew how to fix it (29% vs. 52%), and were twice as likely to need to&#xA;search online to fix the issue (21% vs. 9%) or even make sense of what the&#xA;error meant (15% vs. 7%).&lt;/p&gt;&#xA;&lt;p&gt;We hope to focus on improving toolchain error messages during 2024. These&#xA;survey results suggest this is an area of frustration for developers of all&#xA;experience levels, and will particularly help newer developers get started&#xA;with Go.&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;survey2023h2/err_exp.svg&#34; alt=&#34;Chart of error handling experiences&#34;&#xA;class=&#34;chart&#34; /&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;survey2023h2/err_exp_exp.svg&#34; alt=&#34;Chart of error handling&#xA;experiences, split by duration of Go experience&#34; class=&#34;chart&#34; /&gt;&lt;/p&gt;&#xA;&lt;p&gt;To understand &lt;em&gt;how&lt;/em&gt; these messages might be improved, we asked survey&#xA;respondents an open-ended question: &amp;ldquo;If you could make a wish and improve one&#xA;thing about error messages in the Go toolchain, what would you change?&amp;rdquo;. The&#xA;responses largely align with our hypothesis that good error messages are both&#xA;understandable and actionable. The most common response was some form of &amp;ldquo;Help&#xA;me understand what led to this error&amp;rdquo; (36%), 21% of respondents explicitly&#xA;asked for guidance to fix the problem, and 14% of respondents called out&#xA;languages such as Rust or Elm as exemplars which strive to do both of these&#xA;things. In the words of one respondent:&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&amp;ldquo;For compilation errors, Elm or Rust-style output pinpointing exact issue in&#xA;the source code. Errors should include suggestions to fix them where&#xA;possible&amp;hellip; I think a general policy of &amp;lsquo;optimize error output to be read by&#xA;humans&amp;rsquo; with &amp;lsquo;provide suggestions where possible&amp;rsquo; would be very welcome&#xA;here.&amp;rdquo; &lt;span class=&#34;quote_source&#34;&gt;&amp;mdash; Professional Go developer w/ 5 &amp;ndash; 9&#xA;years of experience&lt;/span&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;Understandably, there is a fuzzy conceptual boundary between toolchain error&#xA;messages and runtime error messages. For example, one of the top requests&#xA;involved improved stack traces or other approaches to assist debugging runtime&#xA;crashes (22%). Similarly, a surprising theme in 4% of the feedback was about&#xA;challenges with getting help from the &lt;code&gt;go&lt;/code&gt; command itself. These are great&#xA;examples of the Go community helping us identify related pain points that&#xA;weren&amp;rsquo;t otherwise on our radar. We started this investigation focused on&#xA;improving compile-time errors, but one of the core areas Go developers would&#xA;like to see improved actually relates to run-time errors, while another was&#xA;about the &lt;code&gt;go&lt;/code&gt; command&amp;rsquo;s help system.&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&amp;ldquo;When an error is thrown, the call stack can be huge and includes a bunch of&#xA;files I don&amp;rsquo;t care about. I just want to know where the problem is in MY&#xA;code, not the library I&amp;rsquo;m using, or how the panic was handled.&amp;rdquo; &lt;span&#xA;class=&#34;quote_source&#34;&gt;&amp;mdash; Professional Go developer w/ 1 &amp;ndash; 2 years of&#xA;experience&lt;/span&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&amp;ldquo;Getting help via `go help run` dumps a wall of text, with links to&#xA;further readings to find the available command-line flags. Or the fact that&#xA;it understands `go run &amp;ndash;help` but instead of showing the help, it says&#xA;&amp;lsquo;please run go help run instead&amp;rsquo;. Just show me list of flags in `go run&#xA;&amp;ndash;help`.&amp;rdquo; &lt;span class=&#34;quote_source&#34;&gt;&amp;mdash; Professional Go developer w/ 3 &amp;ndash;&#xA;4 years of experience&lt;/span&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;&lt;img src=&#34;survey2023h2/text_err_wish.svg&#34; alt=&#34;Chart of potential improvements&#xA;for Go&#39;s error messages&#34; class=&#34;chart&#34; /&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;microservices&#34;&gt;Microservices&lt;/h2&gt;&#xA;&lt;p&gt;We commonly hear that developers find Go to be a great fit for microservices,&#xA;but we have never tried to quantify how many Go developers have adopted this&#xA;type of service architecture, understand how those services communicate with&#xA;one another, or the challenges developers encounter when working on them. This&#xA;year we added a few questions to better understand this space.&lt;/p&gt;&#xA;&lt;p&gt;A plurality of respondents said they work mostly on microservices (43%), with&#xA;another ¼ saying they work on a mix of both microservices and monoliths. Only&#xA;about ⅕ of respondents work mostly on monolithic Go applications. This is one&#xA;of the few areas where we see differences based on the size of organization&#xA;respondents work at&amp;mdash;large organizations seem more likely to have adopted a&#xA;microservice architecture than smaller companies. Respondents from large&#xA;organizations (&amp;gt;1,000 employees) were most likely to say they work on&#xA;microservices (55%), with only 11% of these respondents working primarily on&#xA;monoliths.&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;survey2023h2/service_arch.svg&#34; alt=&#34;Chart of respondents&#39; primary&#xA;service architecture&#34; class=&#34;chart&#34; /&gt;&lt;/p&gt;&#xA;&lt;p&gt;We see some bifurcation in the number of microservices comprising Go&#xA;platforms. One group is composed of a handful (2 to 5) of services (40%),&#xA;while the other consists of larger collections, with a minimum of 10 component&#xA;services (37%). The number of microservices involved does not appear to be&#xA;correlated with organization size.&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;survey2023h2/service_num.svg&#34; alt=&#34;Chart of the number of&#xA;microservices respondents&#39; systems involve&#34; class=&#34;chart&#34; /&gt;&lt;/p&gt;&#xA;&lt;p&gt;A large majority of respondents use some form of direct response request&#xA;(e.g., RPC, HTTP, etc.) for microservice communication (72%). A smaller&#xA;proportion use message queues (14%) or a pub/sub approach (9%); again, we see&#xA;no differences here based on organization size.&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;survey2023h2/service_comm.svg&#34; alt=&#34;Chart of how microservices&#xA;communicate with one another&#34; class=&#34;chart&#34; /&gt;&lt;/p&gt;&#xA;&lt;p&gt;A majority of respondents build microservices in a polyglot of languages, with&#xA;only about ¼ exclusively using Go. Python is the most common companion&#xA;language (33%), alongside Node.js (28%) and Java (26%). We again see&#xA;differences based on organization size, with larger organizations more likely&#xA;to be integrating Python (43%) and Java (36%) microservices, while smaller&#xA;organizations are a bit more likely to only use Go (30%). Other languages&#xA;appeared to be used equally based on organization size.&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;survey2023h2/service_lang.svg&#34; alt=&#34;Chart of other languages that Go&#xA;microservices interact with&#34; class=&#34;chart&#34; /&gt;&lt;/p&gt;&#xA;&lt;p&gt;Overall, respondents told us testing and debugging were their biggest&#xA;challenge when writing microservice-based applications, followed by&#xA;operational complexity. Many other challenges occupy the long tail on this&#xA;graph, though &amp;ldquo;portability&amp;rdquo; stands out as a non-issue for most respondents. We&#xA;interpret this to mean that such services aren&amp;rsquo;t intended to be portable&#xA;(beyond basic containerization); for example, if an organization&amp;rsquo;s&#xA;microservices are initially powered by PostgreSQL databases, developers aren&amp;rsquo;t&#xA;concerned with potentially porting this to an Oracle database in the near&#xA;future.&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;survey2023h2/service_challenge.svg&#34; alt=&#34;Chart of challenges&#xA;respondents face when writing microservice-based applications&#34; class=&#34;chart&#34; /&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;modules&#34;&gt;Module authorship and maintenance&lt;/h2&gt;&#xA;&lt;p&gt;Go has a vibrant ecosystem of community-driven modules, and we want to&#xA;understand the motivations and challenges faced by developers who maintain&#xA;these modules. We found that about ⅕ of respondents maintain (or used to&#xA;maintain) an open-source Go module. This was a surprisingly high proportion,&#xA;and may be biased due to how we share this survey: module maintainers may be&#xA;more likely to closely follow the Go blog (where this survey is announced)&#xA;than other Go developers.&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;survey2023h2/mod_maintainer.svg&#34; alt=&#34;Chart of how many respondents&#xA;have served as a maintainer for a public Go module&#34; class=&#34;chart&#34; /&gt;&lt;/p&gt;&#xA;&lt;p&gt;Module maintainers appear to be largely self-motivated&amp;mdash;they report working&#xA;on modules that they need for personal (58%) or work (56%) projects, that they&#xA;do so because they enjoy working on these modules (63%) and being part of the&#xA;public Go community (44%), and that they learn useful skills from their module&#xA;maintainership (44%). More external motivations, such as receiving recognition&#xA;(15%), career advancement (36%), or cash money (20%) are towards the bottom of&#xA;the list.&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;survey2023h2/mod_motivation.svg&#34; alt=&#34;Chart of the motivations of&#xA;public module maintainers&#34; class=&#34;chart&#34; /&gt;&lt;/p&gt;&#xA;&lt;p&gt;Given the forms of &lt;a href=&#34;https://en.wikipedia.org/wiki/Motivation#Intrinsic_and_extrinsic&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;intrinsic&#xA;motivation&lt;/a&gt; identified above, it&#xA;follows that a key challenge for module maintainers is finding time to devote&#xA;to their module (41%). While this might not seem like an actionable finding in&#xA;itself (we can&amp;rsquo;t give Go developers an extra hour or two each day, right?),&#xA;it&amp;rsquo;s a helpful lens through which to view module tooling and&#xA;development&amp;mdash;these tasks are most likely occurring while the developer is&#xA;already pressed for time, and perhaps it&amp;rsquo;s been weeks or months since they&#xA;last had an opportunity to work on it, so things aren&amp;rsquo;t fresh in their memory.&#xA;Thus, aspects like understandable and actionable error messages can be&#xA;particularly helpful: rather than require someone to once again search for&#xA;specific &lt;code&gt;go&lt;/code&gt; command syntax, perhaps the error output could provide the&#xA;solution they need right in their terminal.&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;survey2023h2/mod_challenge.svg&#34; alt=&#34;Chart of challenges respondents&#xA;face when maintaining public Go modules&#34; class=&#34;chart&#34; /&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;demographics&#34;&gt;Demographics&lt;/h2&gt;&#xA;&lt;p&gt;Most survey respondents reported using Go for their primary job (78%), and a&#xA;majority (59%) said they use it for personal or open-source projects. In fact,&#xA;it&amp;rsquo;s common for respondents to use Go for &lt;em&gt;both&lt;/em&gt; work and personal/OSS&#xA;projects, with 43% of respondents saying they use Go in each of these&#xA;situations.&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;survey2023h2/where.svg&#34; alt=&#34;Chart of situations in which&#xA;respondents recently used Go&#34; class=&#34;chart&#34; /&gt;&lt;/p&gt;&#xA;&lt;p&gt;The majority of respondents have been working with Go for under five years&#xA;(68%). As we&amp;rsquo;ve seen in &lt;a href=&#34;/blog/survey2023-q1-results#novice-respondents-are-more-likely-to-prefer-windows-than-more-experienced-respondents&#34;&gt;prior&#xA;years&lt;/a&gt;,&#xA;people who found this survey via VS Code tended to be less experienced than&#xA;people who found the survey via other channels.&lt;/p&gt;&#xA;&lt;p&gt;When we break down where people use Go by their experience level, two findings&#xA;stand out. First, a majority of respondents from all experience levels said&#xA;they&amp;rsquo;re using Go professionally; indeed, for people with over two years of&#xA;experience, the vast majority use Go at work (85% &amp;ndash; 91%). A similar trend&#xA;exists for open-source development. The second finding is that developers with&#xA;less Go experience are more likely to be using Go to expand their skill set&#xA;(38%) or to evaluate it for use at work (13%) than more experienced Go&#xA;developers. We interpret this to mean that many Gophers initially view Go as&#xA;part of &amp;ldquo;upskilling&amp;rdquo; or expanding their understanding of software development,&#xA;but that within a year or two, they look to Go as more of a tool for doing&#xA;than learning.&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;survey2023h2/go_exp.svg&#34; alt=&#34;Chart of how long respondents have&#xA;been working with Go&#34; class=&#34;chart&#34; /&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;survey2023h2/where_exp.svg&#34; alt=&#34;Chart of situations in which&#xA;respondents recently used Go, split by their level of Go experience&#34;&#xA;class=&#34;chart&#34; /&gt;&lt;/p&gt;&#xA;&lt;p&gt;The most common use cases for Go continue to be API/RPC services (74%) and&#xA;command line tools (62%). People tell us Go is a great choice for these types&#xA;of software for several reasons, including its built-in HTTP server and&#xA;concurrency primitives, ease of cross-compilation, and single-binary&#xA;deployments.&lt;/p&gt;&#xA;&lt;p&gt;The intended audience for much of this tooling is in business settings (62%),&#xA;with 17% of respondents reporting that they develop primarily for more&#xA;consumer-oriented applications. This isn&amp;rsquo;t surprising given the low use of Go&#xA;for consumer-focused applications such as desktop, mobile, or gaming, vs. its&#xA;very high use for backend services, CLI tooling, and cloud development, but it&#xA;is a useful confirmation of how heavily Go is used in B2B settings.&lt;/p&gt;&#xA;&lt;p&gt;We also looked for differences based on respondents&amp;rsquo; level of experience with&#xA;Go and organization size. More experienced Go developers reported building a&#xA;wider variety of different things in Go; this trend was consistent across&#xA;every category of app or service. We did not find any notable differences in&#xA;what respondents are building based on their organization size.&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;survey2023h2/what.svg&#34; alt=&#34;Chart of the types of things respondents&#xA;are building with Go&#34; class=&#34;chart&#34; /&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;survey2023h2/enduser.svg&#34; alt=&#34;Chart of the audience using the&#xA;software respondents build&#34; class=&#34;chart&#34; /&gt;&lt;/p&gt;&#xA;&lt;p&gt;Respondents were about equally likely to say this was the first time they&amp;rsquo;ve&#xA;responded to the Go Developer Survey vs. saying they had taken this survey&#xA;before. There is a meaningful difference between people who learned about this&#xA;survey via the Go blog, where 61% reported taking this survey previously, vs.&#xA;people who learned about this survey via a notification in VS Code, where only&#xA;31% said they&amp;rsquo;ve previously taken this survey. We don&amp;rsquo;t expect people to&#xA;perfectly recall every survey they&amp;rsquo;ve responded to on the internet, but this&#xA;gives us some confidence that we&amp;rsquo;re hearing from a balanced mix of new and&#xA;repeat respondents with each survey. Further, this tells us our combination of&#xA;social media posts and random in-editor sampling are both necessary for&#xA;hearing from a diverse set of Go developers.&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;survey2023h2/return_respondent.svg&#34; alt=&#34;Chart of how many&#xA;respondents said they have taken this survey before&#34; class=&#34;chart&#34; /&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;firmographics&#34;&gt;Firmographics&lt;/h2&gt;&#xA;&lt;p&gt;Respondents to this survey reported working at a mix of different&#xA;organizations, from thousand-person-plus enterprises (27%), to midsize&#xA;businesses (25%) and smaller organizations with &amp;lt; 100 employees (44%). About&#xA;half of respondents work in the technology industry (50%), a large increase&#xA;over the next most-common industry&amp;mdash;financial services&amp;mdash;at 13%.&lt;/p&gt;&#xA;&lt;p&gt;This is statistically unchanged from the past few Go Developer Surveys&amp;mdash;we&#xA;continue to hear from people in different countries and in organizations of&#xA;different sizes and industries at consistent rates year after year.&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;survey2023h2/org_size.svg&#34; alt=&#34;Chart of the different organization&#xA;sizes where respondents use Go&#34; class=&#34;chart&#34; /&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;survey2023h2/industry.svg&#34; alt=&#34;Chart of the different industries&#xA;where respondents use Go&#34; class=&#34;chart&#34; /&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;survey2023h2/location.svg&#34; alt=&#34;Chart of countries or regions where&#xA;respondents are located&#34; class=&#34;chart&#34; /&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;methodology&#34;&gt;Methodology&lt;/h2&gt;&#xA;&lt;p&gt;Most survey respondents &amp;ldquo;self-selected&amp;rdquo; to take this survey, meaning they&#xA;found it on the Go blog or other social Go channels. A potential problem with&#xA;this approach is that people who don&amp;rsquo;t follow these channels are less likely&#xA;to learn about the survey, and might respond differently than people who do&#xA;closely follow them. About 40% of respondents were randomly sampled, meaning&#xA;they responded to the survey after seeing a prompt for it in VS Code (everyone&#xA;using the VS Code Go plugin between mid-July &amp;ndash; mid-August 2023 had a 10% of&#xA;receiving this random prompt). This randomly sampled group helps us generalize&#xA;these findings to the larger community of Go developers.&lt;/p&gt;&#xA;&lt;h3 id=&#34;how-to-read-these-results&#34;&gt;How to read these results&lt;/h3&gt;&#xA;&lt;p&gt;Throughout this report we use charts of survey responses to provide supporting&#xA;evidence for our findings. All of these charts use a similar format. The title&#xA;is the exact question that survey respondents saw. Unless otherwise noted,&#xA;questions were multiple choice and participants could only select a single&#xA;response choice; each chart&amp;rsquo;s subtitle will tell the reader if the question&#xA;allowed multiple response choices or was an open-ended text box instead of a&#xA;multiple choice question. For charts of open-ended text responses, a Go team&#xA;member read and manually categorized the responses. Many open-ended questions&#xA;elicited a wide variety of responses; to keep the chart sizes reasonable, we&#xA;condensed them to a maximum of the top 10 themes, with additional themes all&#xA;grouped under &amp;ldquo;Other&amp;rdquo;. The percentage labels shown in charts are rounded to&#xA;the nearest integer (e.g., 1.4% and 0.8% will both be displayed as 1%), but&#xA;the length of each bar and row ordering are based on the unrounded values.&lt;/p&gt;&#xA;&lt;p&gt;To help readers understand the weight of evidence underlying each finding, we&#xA;included error bars showing the 95% &lt;a href=&#34;https://en.wikipedia.org/wiki/Confidence_interval&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;confidence&#xA;interval&lt;/a&gt; for responses;&#xA;narrower bars indicate increased confidence. Sometimes two or more responses&#xA;have overlapping error bars, which means the relative order of those responses&#xA;is not statistically meaningful (i.e., the responses are effectively tied).&#xA;The lower right of each chart shows the number of people whose responses are&#xA;included in the chart, in the form &amp;ldquo;n = [number of respondents]&amp;rdquo;.&lt;/p&gt;&#xA;&lt;p&gt;We include select quotes from respondents to help clarify many of our&#xA;findings. These quotes include the length of times the respondent has used Go.&#xA;If the respondent said they use Go at work, we refer to them as a&#xA;&amp;ldquo;professional Go developer&amp;rdquo;; if they don&amp;rsquo;t use Go at work but do use Go for&#xA;open-source development, we refer to them as an &amp;ldquo;open-source Go developer&amp;rdquo;.&lt;/p&gt;&#xA;&lt;h2 id=&#34;closing&#34;&gt;Closing&lt;/h2&gt;&#xA;&lt;p&gt;The final question on our survey always asks respondents whether there&amp;rsquo;s&#xA;anything else they&amp;rsquo;d like to share with us about Go. The most common piece of&#xA;feedback people provide is &amp;ldquo;thanks!&amp;rdquo;, and this year was no different (33%). In&#xA;terms of requested language improvements, we see a three-way statistical tie&#xA;between improved expressivity (12%), improved error handling (12%), and&#xA;improved type safety or reliability (9%). Respondents had a variety of ideas&#xA;for improving expressivity, with the general trend of this feedback being&#xA;&amp;ldquo;Here&amp;rsquo;s a specific thing I write frequently, and I wish it were easier to&#xA;express this in Go&amp;rdquo;. The issues with error handling continue to be complaints&#xA;about the verbosity of this code today, while feedback about type safety most&#xA;commonly touched on &lt;a href=&#34;https://en.wikipedia.org/wiki/Tagged_union&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;sum types&lt;/a&gt;.&#xA;This type of high-level feedback is extremely useful when the Go team tries to&#xA;plan focus areas for the coming year, as it tells us general directions in&#xA;which the community is hoping to steer the ecosystem.&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&amp;ldquo;I know about Go&amp;rsquo;s attitude towards simplicity and I appreciate it. I just&#xA;wish there [were] slightly more features. For me it would be better error&#xA;handling (not exceptions though), and maybe some common creature comforts&#xA;like map/reduce/filter and ternary operators. Anything not too obscure&#xA;that&amp;rsquo;ll save me some &amp;lsquo;if&amp;rsquo; statements.&amp;rdquo; &lt;span class=&#34;quote_source&#34;&gt;&amp;mdash;&#xA;Professional Go developer w/ 1 &amp;ndash; 2 years of experience&lt;/span&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&amp;ldquo;Please keep Go in line with the long term values Go established so long ago&#xA;— language and library stability. [&amp;hellip;] It is an environment I can&#xA;rely on to not break my code after 2 or 3 years. For that, thank you very&#xA;much.&amp;rdquo; &lt;span class=&#34;quote_source&#34;&gt;&amp;mdash; Professional Go developer w/ 10+ years&#xA;of experience&lt;/span&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;&lt;img src=&#34;survey2023h2/text_anything_else.svg&#34; alt=&#34;Chart of other topics&#xA;respondents shared with us&#34; class=&#34;chart&#34; /&gt;&lt;/p&gt;&#xA;&lt;p&gt;That&amp;rsquo;s all for this bi-annual iteration of the Go Developer Survey. Thanks to&#xA;everyone who shared their feedback about Go&amp;mdash;we have immense gratitude for&#xA;taking your time to help shape Go&amp;rsquo;s future, and we hope you see some of your&#xA;own feedback reflected in this report. 🩵&lt;/p&gt;&#xA;&lt;p&gt;&amp;mdash; Todd (on behalf of the Go team at Google)&lt;/p&gt;&#xA;&#xA;    &lt;/div&gt;&#xA;&#xA;    &#xA;    &lt;div class=&#34;Article prevnext&#34;&gt;&#xA;    &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;        &lt;p&gt;&#xA;        &#xA;          &#xA;            &lt;b&gt;Next article: &lt;/b&gt;&lt;a href=&#34;/blog/deadcode&#34;&gt;Finding unreachable functions with deadcode&lt;/a&gt;&lt;br&gt;&#xA;          &#xA;        &#xA;        &#xA;          &#xA;            &lt;b&gt;Previous article: &lt;/b&gt;&lt;a href=&#34;/blog/14years&#34;&gt;Fourteen Years of Go&lt;/a&gt;&lt;br&gt;&#xA;          &#xA;        &#xA;        &lt;b&gt;&lt;a href=&#34;/blog/all&#34;&gt;Blog Index&lt;/a&gt;&lt;/b&gt;&#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;    &lt;/div&gt;&#xA;    &#xA;&#xA;  &lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;script src=&#34;/js/jquery.js&#34;&gt;&lt;/script&gt;&#xA;&lt;script src=&#34;/js/playground.js&#34;&gt;&lt;/script&gt;&#xA;&lt;script src=&#34;/js/play.js&#34;&gt;&lt;/script&gt;&#xA;&lt;script src=&#34;/js/godocs.js&#34;&gt;&lt;/script&gt;&#xA;&#xA;</content></entry><entry><title>Fourteen Years of Go</title><id>tag:blog.golang.org,2013:blog.golang.org/14years</id><link rel="alternate" href="https://go.dev/blog/14years"></link><published>2023-11-10T00:00:00+00:00</published><updated>2023-11-10T00:00:00+00:00</updated><author><name></name></author><summary type="html">Happy Birthday, Go!</summary><content type="html">&#xA;&lt;div id=&#34;blog&#34;&gt;&lt;div id=&#34;content&#34;&gt;&#xA;  &lt;div id=&#34;content&#34;&gt;&#xA;&#xA;    &lt;div class=&#34;Article&#34; data-slug=&#34;/blog/14years&#34;&gt;&#xA;    &#xA;    &lt;h1 class=&#34;small&#34;&gt;&lt;a href=&#34;/blog/&#34;&gt;The Go Blog&lt;/a&gt;&lt;/h1&gt;&#xA;    &#xA;&#xA;    &lt;h1&gt;Fourteen Years of Go&lt;/h1&gt;&#xA;      &#xA;      &lt;p class=&#34;author&#34;&gt;&#xA;      Russ Cox, for the Go team&lt;br&gt;&#xA;      10 November 2023&#xA;      &lt;/p&gt;&#xA;      &#xA;      &lt;img src=&#34;/doc/gopher/gopherdrink.png&#34; height=&#34;219&#34; width=&#34;223&#34; align=&#34;right&#34; style=&#34;margin: 0 0 1em 1em;&#34;&gt;&#xA;&lt;p&gt;Today we celebrate the fourteenth birthday of the Go open source release!&#xA;Go has had a great year, with two feature-filled releases and other important milestones.&lt;/p&gt;&#xA;&lt;p&gt;We released &lt;a href=&#34;/blog/go1.20&#34;&gt;Go 1.20 in February&lt;/a&gt;&#xA;and &lt;a href=&#34;/blog/go1.21&#34;&gt;Go 1.21 in August&lt;/a&gt;,&#xA;focusing more on implementation improvements&#xA;than new language changes.&lt;/p&gt;&#xA;&lt;p&gt;Profile-guided optimization (PGO),&#xA;&lt;a href=&#34;/blog/pgo-preview&#34;&gt;previewed in Go 1.20&lt;/a&gt;&#xA;and&#xA;&lt;a href=&#34;/blog/pgo&#34;&gt;released in Go 1.21&lt;/a&gt;,&#xA;allows the Go compiler to read a profile of your program&#xA;and then spend more time optimizing the parts&#xA;of your program that run most often.&#xA;In Go 1.21, workloads typically get between&#xA;2% and 7% CPU usage improvements from enabling PGO.&#xA;See “&lt;a href=&#34;/blog/pgo&#34;&gt;Profile-guided optimization in Go 1.21&lt;/a&gt;” for an overview&#xA;and the &lt;a href=&#34;/doc/pgo&#34;&gt;profile-guided optimization user guide&lt;/a&gt;&#xA;for complete documentation.&lt;/p&gt;&#xA;&lt;p&gt;Go has provided support for gathering coverage profiles during &lt;code&gt;go test&lt;/code&gt;&#xA;&lt;a href=&#34;/blog/cover&#34;&gt;since Go 1.2&lt;/a&gt;.&#xA;Go 1.20 added support for gathering coverage profiles in binaries&#xA;built by &lt;code&gt;go build&lt;/code&gt;,&#xA;allowing you to gather coverage during larger integration tests as well.&#xA;See “&lt;a href=&#34;/blog/integration-test-coverage&#34;&gt;Code coverage for Go integration tests&lt;/a&gt;” for details.&lt;/p&gt;&#xA;&lt;p&gt;Compatibility has been an important part of Go since&#xA;“&lt;a href=&#34;/doc/go1compat&#34;&gt;Go 1 and the Future of Go Programs&lt;/a&gt;”.&#xA;Go 1.21 improved compatibility further&#xA;by expanding the conventions for use of GODEBUG&#xA;in situations where we need to make a change,&#xA;such as an important bug fix,&#xA;that must be permitted but may still break existing programs.&#xA;See the blog post&#xA;“&lt;a href=&#34;/blog/compat&#34;&gt;Backward Compatibility, Go 1.21, and Go 2&lt;/a&gt;”&#xA;for an overview and&#xA;the documentation&#xA;“&lt;a href=&#34;/doc/godebug&#34;&gt;Go, Backwards Compatibility, and GODEBUG&lt;/a&gt;” for details.&lt;/p&gt;&#xA;&lt;p&gt;Go 1.21 also shipped support for built-in toolchain management,&#xA;allowing you to change which version of the&#xA;Go toolchain you use in a specific module&#xA;as easily as you change the versions of other dependencies.&#xA;See the blog post&#xA;“&lt;a href=&#34;/blog/toolchain&#34;&gt;Forward Compatibility and Toolchain Management in Go 1.21&lt;/a&gt;”&#xA;for an overview and the documentation&#xA;“&lt;a href=&#34;/doc/toolchain&#34;&gt;Go Toolchains&lt;/a&gt;”&#xA;for details.&lt;/p&gt;&#xA;&lt;p&gt;Another important tooling achievement was the&#xA;integration of on-disk indexes into&#xA;gopls, the Go LSP server.&#xA;This cut gopls&amp;rsquo;s startup latency and memory usage by 3-5X&#xA;in typical use cases.&#xA;“&lt;a href=&#34;/blog/gopls-scalability&#34;&gt;Scaling gopls for the growing Go ecosystem&lt;/a&gt;”&#xA;explains the technical details.&#xA;You can make sure you&amp;rsquo;re running the latest gopls by running:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;go install golang.org/x/tools/gopls@latest&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Go 1.21 introduced new&#xA;&lt;a href=&#34;/pkg/cmp/&#34;&gt;cmp&lt;/a&gt;,&#xA;&lt;a href=&#34;/pkg/maps/&#34;&gt;maps&lt;/a&gt;,&#xA;and&#xA;&lt;a href=&#34;/pkg/slices/&#34;&gt;slices&lt;/a&gt;&#xA;packages — Go’s first generic standard libraries —&#xA;as well as expanding the set of comparable types.&#xA;For details about that, see the blog post&#xA;“&lt;a href=&#34;/blog/comparable&#34;&gt;All your comparable types&lt;/a&gt;”.&lt;/p&gt;&#xA;&lt;p&gt;Overall, we continue to refine generics&#xA;and to write talks and blog posts explaining&#xA;important details.&#xA;Two notable posts this year were&#xA;“&lt;a href=&#34;/blog/deconstructing-type-parameters&#34;&gt;Deconstructing Type Parameters&lt;/a&gt;”,&#xA;and&#xA;“&lt;a href=&#34;/blog/type-inference&#34;&gt;Everything You Always Wanted to Know About Type Inference – And a Little Bit More&lt;/a&gt;”.&lt;/p&gt;&#xA;&lt;p&gt;Another important new package in Go 1.21 is&#xA;&lt;a href=&#34;/pkg/log/slog/&#34;&gt;log/slog&lt;/a&gt;,&#xA;which adds an official API for&#xA;structured logging to the standard library.&#xA;See “&lt;a href=&#34;/blog/slog&#34;&gt;Structured logging with slog&lt;/a&gt;” for an overview.&lt;/p&gt;&#xA;&lt;p&gt;For the WebAssembly (Wasm) port, Go 1.21 shipped support&#xA;for running on WebAssembly System Interface (WASI) preview 1.&#xA;WASI preview 1 is a new “operating system” interface for Wasm&#xA;that is supported by most server-side Wasm environments.&#xA;See “&lt;a href=&#34;/blog/wasi&#34;&gt;WASI support in Go&lt;/a&gt;” for a walkthrough.&lt;/p&gt;&#xA;&lt;p&gt;On the security side, we are continuing to make sure&#xA;Go leads the way in helping developers understand their&#xA;dependencies and vulnerabilities,&#xA;with &lt;a href=&#34;/blog/govulncheck&#34;&gt;Govulncheck 1.0 launching in July&lt;/a&gt;.&#xA;If you use VS Code, you can run govulncheck directly in your&#xA;editor using the Go extension:&#xA;see &lt;a href=&#34;/doc/tutorial/govulncheck-ide&#34;&gt;this tutorial&lt;/a&gt; to get started.&#xA;And if you use GitHub, you can run govulncheck as part of&#xA;your CI/CD, with the&#xA;&lt;a href=&#34;https://github.com/marketplace/actions/golang-govulncheck-action&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;GitHub Action for govulncheck&lt;/a&gt;.&#xA;For more about checking your dependencies for vulnerability problems,&#xA;see this year&amp;rsquo;s Google I/O talk,&#xA;“&lt;a href=&#34;https://www.youtube.com/watch?v=HSt6FhsPT8c&amp;amp;ab_channel=TheGoProgrammingLanguage&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Build more secure apps with Go and Google&lt;/a&gt;”.)&lt;/p&gt;&#xA;&lt;p&gt;Another important security milestone was&#xA;Go 1.21&amp;rsquo;s highly reproducible toolchain builds.&#xA;See “&lt;a href=&#34;/blog/rebuild&#34;&gt;Perfectly Reproducible, Verified Go Toolchains&lt;/a&gt;” for details,&#xA;including a demonstration of reproducing an Ubuntu Linux Go toolchain&#xA;on a Mac without using any Linux tools at all.&lt;/p&gt;&#xA;&lt;p&gt;It has been a busy year!&lt;/p&gt;&#xA;&lt;p&gt;In Go&amp;rsquo;s 15th year, we&amp;rsquo;ll keep working to make Go the best environment&#xA;for software engineering at scale.&#xA;One change we&amp;rsquo;re particularly excited about is&#xA;redefining for loop &lt;code&gt;:=&lt;/code&gt; semantics to remove the&#xA;potential for accidental aliasing bugs.&#xA;See “&lt;a href=&#34;/blog/loopvar-preview&#34;&gt;Fixing For Loops in Go 1.22&lt;/a&gt;”&#xA;for details,&#xA;including instructions for previewing this change in Go 1.21.&lt;/p&gt;&#xA;&lt;h2 id=&#34;thank-you&#34;&gt;Thank You!&lt;/h2&gt;&#xA;&lt;p&gt;The Go project has always been far more than just us on the Go team at Google.&#xA;Thank you to all our contributors and everyone in the Go community for&#xA;making Go what it is today.&#xA;We wish you all the best in the year ahead.&lt;/p&gt;&#xA;&#xA;    &lt;/div&gt;&#xA;&#xA;    &#xA;    &lt;div class=&#34;Article prevnext&#34;&gt;&#xA;    &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;        &lt;p&gt;&#xA;        &#xA;          &#xA;            &lt;b&gt;Next article: &lt;/b&gt;&lt;a href=&#34;/blog/survey2023-h2-results&#34;&gt;Go Developer Survey 2023 H2 Results&lt;/a&gt;&lt;br&gt;&#xA;          &#xA;        &#xA;        &#xA;          &#xA;            &lt;b&gt;Previous article: &lt;/b&gt;&lt;a href=&#34;/blog/type-inference&#34;&gt;Everything You Always Wanted to Know About Type Inference - And a Little Bit More&lt;/a&gt;&lt;br&gt;&#xA;          &#xA;        &#xA;        &lt;b&gt;&lt;a href=&#34;/blog/all&#34;&gt;Blog Index&lt;/a&gt;&lt;/b&gt;&#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;    &lt;/div&gt;&#xA;    &#xA;&#xA;  &lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;script src=&#34;/js/jquery.js&#34;&gt;&lt;/script&gt;&#xA;&lt;script src=&#34;/js/playground.js&#34;&gt;&lt;/script&gt;&#xA;&lt;script src=&#34;/js/play.js&#34;&gt;&lt;/script&gt;&#xA;&lt;script src=&#34;/js/godocs.js&#34;&gt;&lt;/script&gt;&#xA;&#xA;</content></entry><entry><title>Everything You Always Wanted to Know About Type Inference - And a Little Bit More</title><id>tag:blog.golang.org,2013:blog.golang.org/type-inference</id><link rel="alternate" href="https://go.dev/blog/type-inference"></link><published>2023-10-09T00:00:00+00:00</published><updated>2023-10-09T00:00:00+00:00</updated><author><name></name></author><summary type="html">A description of how type inference for Go works. Based on the GopherCon 2023 talk with the same title.</summary><content type="html">&#xA;&lt;div id=&#34;blog&#34;&gt;&lt;div id=&#34;content&#34;&gt;&#xA;  &lt;div id=&#34;content&#34;&gt;&#xA;&#xA;    &lt;div class=&#34;Article&#34; data-slug=&#34;/blog/type-inference&#34;&gt;&#xA;    &#xA;    &lt;h1 class=&#34;small&#34;&gt;&lt;a href=&#34;/blog/&#34;&gt;The Go Blog&lt;/a&gt;&lt;/h1&gt;&#xA;    &#xA;&#xA;    &lt;h1&gt;Everything You Always Wanted to Know About Type Inference - And a Little Bit More&lt;/h1&gt;&#xA;      &#xA;      &lt;p class=&#34;author&#34;&gt;&#xA;      Robert Griesemer&lt;br&gt;&#xA;      9 October 2023&#xA;      &lt;/p&gt;&#xA;      &#xA;      &lt;p&gt;This is the blog version of my talk on type inference at GopherCon 2023 in San Diego,&#xA;slightly expanded and edited for clarity.&lt;/p&gt;&#xA;&lt;h2 id=&#34;what-is-type-inference&#34;&gt;What is type inference?&lt;/h2&gt;&#xA;&lt;p&gt;Wikipedia defines type inference as follows:&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;Type inference is the ability to automatically deduce, either partially or fully,&#xA;the type of an expression at compile time.&#xA;The compiler is often able to infer the type of a variable or the type signature of&#xA;a function, without explicit type annotations having been given.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;The key phrase here is &amp;ldquo;automatically deduce &amp;hellip; the type of an expression&amp;rdquo;.&#xA;Go supported a basic form of type inference from the start:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;const x = expr  // the type of x is the type of expr&#xA;var x = expr&#xA;x := expr&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;No explicit types are given in these declarations,&#xA;and therefore the types of the constant and variables &lt;code&gt;x&lt;/code&gt; on the left of &lt;code&gt;=&lt;/code&gt; and &lt;code&gt;:=&lt;/code&gt;&#xA;are the types of the respective initialization expressions, on the right.&#xA;We say that the types are &lt;em&gt;inferred&lt;/em&gt; from (the types of) their initialization expressions.&#xA;With the introduction of generics in Go 1.18, Go&amp;rsquo;s type inference abilities&#xA;were significantly expanded.&lt;/p&gt;&#xA;&lt;h3 id=&#34;why-type-inference&#34;&gt;Why type inference?&lt;/h3&gt;&#xA;&lt;p&gt;In non-generic Go code, the effect of leaving away types is most pronounced in a short variable declaration.&#xA;Such a declaration combines type inference and a little bit of syntactic&#xA;sugar—the ability to leave away the &lt;code&gt;var&lt;/code&gt; keyword—into one very compact statement.&#xA;Consider the following map variable declaration:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;var m map[string]int = map[string]int{}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;vs&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;m := map[string]int{}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Omitting the type on the left of &lt;code&gt;:=&lt;/code&gt; removes repetition and at the same time increases readability.&lt;/p&gt;&#xA;&lt;p&gt;Generic Go code has the potential to significantly increase the number of types appearing in code:&#xA;without type inference, each generic function and type instantiation requires type arguments.&#xA;Being able to omit them becomes even more important.&#xA;Consider using the following two functions from the new&#xA;&lt;a href=&#34;https://pkg.go.dev/slices&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;slices package&lt;/a&gt;:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;package slices&#xA;func BinarySearch[S ~[]E, E cmp.Ordered](x S, target E) (int, bool)&#xA;func Sort[S ~[]E, E cmp.Ordered](x S)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Without type inference, calling &lt;code&gt;BinarySearch&lt;/code&gt; and &lt;code&gt;Sort&lt;/code&gt; requires explicit type arguments:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;type List []int&#xA;var list List&#xA;slices.Sort[List, int](list)&#xA;index, found := slices.BinarySearch[List, int](list, 42)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;We&amp;rsquo;d rather not repeat &lt;code&gt;[List, int]&lt;/code&gt; with each such generic function call.&#xA;With type inference the code simplifies to:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;type List []int&#xA;var list List&#xA;slices.Sort(list)&#xA;index, found := slices.BinarySearch(list, 42)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;This is both cleaner and more compact.&#xA;In fact it looks exactly like non-generic code,&#xA;and type inference makes this possible.&lt;/p&gt;&#xA;&lt;p&gt;Importantly, type inference is an optional mechanism:&#xA;if type arguments make code clearer, by all means, write them down.&lt;/p&gt;&#xA;&lt;h2 id=&#34;type-inference-is-a-form-of-type-pattern-matching&#34;&gt;Type inference is a form of type pattern matching&lt;/h2&gt;&#xA;&lt;p&gt;Inference compares type patterns,&#xA;where a type pattern is a type containing type parameters.&#xA;For reasons that will become obvious in a bit, type parameters&#xA;are sometimes also called &lt;em&gt;type variables&lt;/em&gt;.&#xA;Type pattern matching allows us to infer the types that need&#xA;to go into these type variables.&#xA;Let&amp;rsquo;s consider a short example:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;// From the slices package&#xA;// func Sort[S ~[]E, E cmp.Ordered](x S)&#xA;&#xA;type List []int&#xA;var list List&#xA;slices.Sort(list)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;The &lt;code&gt;Sort&lt;/code&gt; function call passes the &lt;code&gt;list&lt;/code&gt; variable as function argument for the parameter &lt;code&gt;x&lt;/code&gt;&#xA;of &lt;a href=&#34;https://pkg.go.dev/slices#Sort&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;slices.Sort&lt;/code&gt;&lt;/a&gt;.&#xA;Therefore the type of &lt;code&gt;list&lt;/code&gt;, which is &lt;code&gt;List&lt;/code&gt;, must match the type of &lt;code&gt;x&lt;/code&gt;, which is type parameter &lt;code&gt;S&lt;/code&gt;.&#xA;If &lt;code&gt;S&lt;/code&gt; has the type &lt;code&gt;List&lt;/code&gt;, this assignment becomes valid.&#xA;In reality, the &lt;a href=&#34;/ref/spec#Assignability&#34;&gt;rules for assignments&lt;/a&gt; are complicated,&#xA;but for now it&amp;rsquo;s good enough to assume that the types must be identical.&lt;/p&gt;&#xA;&lt;p&gt;Once we have inferred the type for &lt;code&gt;S&lt;/code&gt;, we can look at the&#xA;&lt;a href=&#34;/ref/spec#Type_constraints&#34;&gt;type constraint&lt;/a&gt; for &lt;code&gt;S&lt;/code&gt;.&#xA;It says—because of the tilde &lt;code&gt;~&lt;/code&gt; symbol—that the&#xA;&lt;a href=&#34;/ref/spec#Underlying_types&#34;&gt;&lt;em&gt;underlying type&lt;/em&gt;&lt;/a&gt; of &lt;code&gt;S&lt;/code&gt;&#xA;must be the slice &lt;code&gt;[]E&lt;/code&gt;.&#xA;The underlying type of &lt;code&gt;S&lt;/code&gt; is &lt;code&gt;[]int&lt;/code&gt;, therefore &lt;code&gt;[]int&lt;/code&gt; must match &lt;code&gt;[]E&lt;/code&gt;,&#xA;and with that we can conclude that &lt;code&gt;E&lt;/code&gt; must be &lt;code&gt;int&lt;/code&gt;.&#xA;We&amp;rsquo;ve been able to find types for &lt;code&gt;S&lt;/code&gt; and &lt;code&gt;E&lt;/code&gt; such that corresponding types match.&#xA;Inference has succeeded!&lt;/p&gt;&#xA;&lt;p&gt;Here&amp;rsquo;s a more complicated scenario where we have a lot of type parameters:&#xA;&lt;code&gt;S1&lt;/code&gt;, &lt;code&gt;S2&lt;/code&gt;, &lt;code&gt;E1&lt;/code&gt;, and &lt;code&gt;E2&lt;/code&gt; from &lt;code&gt;slices.EqualFunc&lt;/code&gt;, and &lt;code&gt;E1&lt;/code&gt; and &lt;code&gt;E2&lt;/code&gt; from the generic function &lt;code&gt;equal&lt;/code&gt;.&#xA;The local function &lt;code&gt;foo&lt;/code&gt; calls &lt;code&gt;slices.EqualFunc&lt;/code&gt; with the &lt;code&gt;equal&lt;/code&gt; function as an argument:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;// From the slices package&#xA;// func EqualFunc[S1 ~[]E1, S2 ~[]E2, E1, E2 any](s1 S1, s2 S2, eq func(E1, E2) bool) bool&#xA;&#xA;// Local code&#xA;func equal[E1, E2 comparable](E1, E2) bool { … }&#xA;&#xA;func foo(list1 []int, list2 []float64) {&#xA;    …&#xA;    if slices.EqualFunc(list1, list2, equal) {&#xA;        …&#xA;    }&#xA;    …&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;This is an example where type inference really shines as we can potentially leave away six type arguments,&#xA;one for each of the type parameters.&#xA;The type pattern matching approach still works, but we can see how it may get complicated quickly&#xA;because the number of type relationships is proliferating.&#xA;We need a systematic approach to determine which type parameters and which types get involved with which patterns.&lt;/p&gt;&#xA;&lt;p&gt;It helps to look at type inference in a slightly different way.&lt;/p&gt;&#xA;&lt;h2 id=&#34;type-equations&#34;&gt;Type equations&lt;/h2&gt;&#xA;&lt;p&gt;We can reframe type inference as a problem of solving type equations.&#xA;Solving equations is something that we are all familiar with from high school algebra.&#xA;Luckily, solving type equations is a simpler problem as we will see shortly.&lt;/p&gt;&#xA;&lt;p&gt;Let&amp;rsquo;s look again at our earlier example:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;// From the slices package&#xA;// func Sort[S ~[]E, E cmp.Ordered](x S)&#xA;&#xA;type List []int&#xA;var list List&#xA;slices.Sort(list)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Inference succeeds if the type equations below can be solved.&#xA;Here &lt;code&gt;≡&lt;/code&gt; stands for &lt;a href=&#34;/ref/spec#Type_identity&#34;&gt;&lt;em&gt;is identical to&lt;/em&gt;&lt;/a&gt;,&#xA;and &lt;code&gt;under(S)&lt;/code&gt; represents&#xA;the &lt;a href=&#34;/ref/spec#Underlying_types&#34;&gt;underlying type&lt;/a&gt;&#xA;of &lt;code&gt;S&lt;/code&gt;:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;S ≡ List        // find S such that S ≡ List is true&#xA;under(S) ≡ []E  // find E such that under(S) ≡ []E is true&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;The type parameters are the &lt;em&gt;variables&lt;/em&gt; in the equations.&#xA;Solving the equations means finding values (type arguments) for these variables&#xA;(type parameters), such that the equations become true.&#xA;This view makes the type inference problem more tractable because&#xA;it gives us a formal framework that allows us to write down the information that&#xA;flows into inference.&lt;/p&gt;&#xA;&lt;h3 id=&#34;being-precise-with-type-relations&#34;&gt;Being precise with type relations&lt;/h3&gt;&#xA;&lt;p&gt;Until now we have simply talked about types having to be&#xA;&lt;a href=&#34;/ref/spec#Type_identity&#34;&gt;identical&lt;/a&gt;.&#xA;But for actual Go code that is too strong a requirement.&#xA;In the previous example, &lt;code&gt;S&lt;/code&gt; need not be identical to &lt;code&gt;List&lt;/code&gt;,&#xA;rather &lt;code&gt;List&lt;/code&gt; must be &lt;a href=&#34;/ref/spec#Assignability&#34;&gt;assignable&lt;/a&gt; to &lt;code&gt;S&lt;/code&gt;.&#xA;Similarly, &lt;code&gt;S&lt;/code&gt; must &lt;a href=&#34;/ref/spec#Satisfying_a_type_constraint&#34;&gt;satisfy&lt;/a&gt;&#xA;its corresponding type constraint.&#xA;We can formulate our type equations more precisely by using specific operators that&#xA;we write as &lt;code&gt;:≡&lt;/code&gt; and &lt;code&gt;∈&lt;/code&gt;:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;S :≡ List         // List is assignable to S&#xA;S ∈ ~[]E          // S satisfies constraint ~[]E&#xA;E ∈ cmp.Ordered   // E satisfies constraint cmp.Ordered&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Generally, we can say that type equations come in three forms:&#xA;two types must be identical, one type must be assignable to the other type,&#xA;or one type must satisfy a type constraint:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;X ≡ Y             // X and Y must be identical&#xA;X :≡ Y            // Y is assignable to X&#xA;X ∈ Y             // X satisfies constraint Y&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;(Note: In the GopherCon talk we used the symbols &lt;code&gt;≡&lt;/code&gt;&lt;sub&gt;A&lt;/sub&gt; for &lt;code&gt;:≡&lt;/code&gt; and&#xA;&lt;code&gt;≡&lt;/code&gt;&lt;sub&gt;C&lt;/sub&gt; for &lt;code&gt;∈&lt;/code&gt;.&#xA;We believe &lt;code&gt;:≡&lt;/code&gt; more clearly evokes an assignment relation;&#xA;and &lt;code&gt;∈&lt;/code&gt; directly expresses that the type represented by a type parameter must&#xA;be an element of its constraint&amp;rsquo;s &lt;a href=&#34;/ref/spec#Interface_types&#34;&gt;type set&lt;/a&gt;.)&lt;/p&gt;&#xA;&lt;h3 id=&#34;sources-of-type-equations&#34;&gt;Sources of type equations&lt;/h3&gt;&#xA;&lt;p&gt;In a generic function call we may have explicit type arguments,&#xA;though most of the time we hope that they can be inferred.&#xA;Typically we also have ordinary function arguments.&#xA;Each explicit type argument contributes a (trivial) type equation:&#xA;the type parameter must be identical to the type argument because the code says so.&#xA;Each ordinary function argument contributes another type equation:&#xA;the function argument must be assignable to its corresponding function parameter.&#xA;And finally, each type constraint provides a type equation as well&#xA;by constraining what types satisfy the constraint.&lt;/p&gt;&#xA;&lt;p&gt;Altogether, this produces &lt;code&gt;n&lt;/code&gt; type parameters and &lt;code&gt;m&lt;/code&gt; type equations.&#xA;In contrast to basic high school algebra, &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;m&lt;/code&gt; don&amp;rsquo;t have to be the same for&#xA;type equations to be solvable.&#xA;For instance, the single equation below allows us to infer the type arguments for&#xA;two type parameters:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;map[K]V ≡ map[int]string  // K ➞ int, V ➞ string (n = 2, m = 1)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Let&amp;rsquo;s look at each of these sources of type equations in turn:&lt;/p&gt;&#xA;&lt;h4 id=&#34;1-type-equations-from-type-arguments&#34;&gt;1. Type equations from type arguments&lt;/h4&gt;&#xA;&lt;p&gt;For each type parameter declaration&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;func f[…, P constraint, …]…&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;and explicitly provided type argument&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;f[…, A, …]…&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;we get the type equation&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;P ≡ A&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;We can trivially solve this for &lt;code&gt;P&lt;/code&gt;: &lt;code&gt;P&lt;/code&gt; must be &lt;code&gt;A&lt;/code&gt; and we write &lt;code&gt;P ➞ A&lt;/code&gt;.&#xA;In other words, there is nothing to do here.&#xA;We could still write down the respective type equation for completeness,&#xA;but in this case, the Go compiler simply substitutes the type arguments&#xA;for their type parameters throughout and then those type parameters are&#xA;gone and we can forget about them.&lt;/p&gt;&#xA;&lt;h4 id=&#34;2-type-equations-from-assignments&#34;&gt;2. Type equations from assignments&lt;/h4&gt;&#xA;&lt;p&gt;For each function argument &lt;code&gt;x&lt;/code&gt; passed to a function parameter &lt;code&gt;p&lt;/code&gt;&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;f(…, x, …)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;where &lt;code&gt;p&lt;/code&gt; or &lt;code&gt;x&lt;/code&gt; contain type parameters,&#xA;the type of &lt;code&gt;x&lt;/code&gt; must be assignable to the type of the parameter &lt;code&gt;p&lt;/code&gt;.&#xA;We can express this with the equation&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;𝑻(p) :≡ 𝑻(x)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;where &lt;code&gt;𝑻(x)&lt;/code&gt; means &amp;ldquo;the type of &lt;code&gt;x&lt;/code&gt;&amp;rdquo;.&#xA;If neither &lt;code&gt;p&lt;/code&gt; nor &lt;code&gt;x&lt;/code&gt; contains type parameters, there is no type variable to solve for:&#xA;the equation is either true because the assignment is valid Go code,&#xA;or false if the code is invalid.&#xA;For this reason, type inference only considers types that contain type parameters of the&#xA;involved function (or functions).&lt;/p&gt;&#xA;&lt;p&gt;Starting with Go 1.21, an uninstantiated or partially instantiated function&#xA;(but not a function call) may also be assigned to a function-typed variable, as in:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;// From the slices package&#xA;// func Sort[S ~[]E, E cmp.Ordered](x S)&#xA;&#xA;var intSort func([]int) = slices.Sort&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Analogous to parameter passing, such assignments lead to a corresponding&#xA;type equation. For this example it would be&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;𝑻(intSort) :≡ 𝑻(slices.Sort)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;or simplified&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;func([]int) :≡ func(S)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;together with equations for the constraints for &lt;code&gt;S&lt;/code&gt; and &lt;code&gt;E&lt;/code&gt; from &lt;code&gt;slices.Sort&lt;/code&gt;&#xA;(see below).&lt;/p&gt;&#xA;&lt;h4 id=&#34;3-type-equations-from-constraints&#34;&gt;3. Type equations from constraints&lt;/h4&gt;&#xA;&lt;p&gt;Finally, for each type parameter &lt;code&gt;P&lt;/code&gt; for which we want to infer a type argument,&#xA;we can extract a type equation from its constraint because the type parameter&#xA;must satisfy the constraint. Given the declaration&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;func f[…, P constraint, …]…&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;we can write down the equation&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;P ∈ constraint&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Here, the &lt;code&gt;∈&lt;/code&gt; means &amp;ldquo;must satisfy constraint&amp;rdquo; which is (almost) the same as&#xA;being a type element of the constraint&amp;rsquo;s type set.&#xA;We will see later that some constraints (such as &lt;code&gt;any&lt;/code&gt;) are not useful or&#xA;currently cannot be used due to limitations of the implementation.&#xA;Inference simply ignores the respective equations in those cases.&lt;/p&gt;&#xA;&lt;h3 id=&#34;type-parameters-and-equations-may-be-from-multiple-functions&#34;&gt;Type parameters and equations may be from multiple functions&lt;/h3&gt;&#xA;&lt;p&gt;In Go 1.18, inferred type parameters had to all be from the same function.&#xA;Specifically, it was not possible to pass a generic, uninstantiated or partially instantiated&#xA;function as a function argument,&#xA;or assign it to a (function-typed) variable.&lt;/p&gt;&#xA;&lt;p&gt;As mentioned earlier, in Go 1.21 type inference also works in these cases.&#xA;For instance, the generic function&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;func myEq[P comparable](x, y P) bool { return x == y }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;can be assigned to a variable of function type&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;var strEq func(x, y string) bool = myEq  // same as using myEq[string]&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;without &lt;code&gt;myEq&lt;/code&gt; being fully instantiated,&#xA;and type inference will infer that the type argument for &lt;code&gt;P&lt;/code&gt; must be &lt;code&gt;string&lt;/code&gt;.&lt;/p&gt;&#xA;&lt;p&gt;Furthermore, a generic function may be used uninstantiated or partially instantiated as&#xA;an argument to another, possibly generic function:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;// From the slices package&#xA;// func CompactFunc[S ~[]E, E any](s S, eq func(E, E) bool) S&#xA;&#xA;type List []int&#xA;var list List&#xA;result := slices.CompactFunc(list, myEq)  // same as using slices.CompactFunc[List, int](list, myEq[int])&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;In this last example, type inference determines the type arguments for &lt;code&gt;CompactFunc&lt;/code&gt;&#xA;and &lt;code&gt;myEq&lt;/code&gt;.&#xA;More generally, type parameters from arbitrarily many functions may need to be inferred.&#xA;With multiple functions involved, type equations may also be from or involve multiple functions.&#xA;In the &lt;code&gt;CompactFunc&lt;/code&gt; example we end up with three type parameters and five type equations:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;Type parameters and constraints:&#xA;    S ~[]E&#xA;    E any&#xA;    P comparable&#xA;&#xA;Explicit type arguments:&#xA;    none&#xA;&#xA;Type equations:&#xA;    S :≡ List&#xA;    func(E, E) bool :≡ func(P, P) bool&#xA;    S ∈ ~[]E&#xA;    E ∈ any&#xA;    P ∈ comparable&#xA;&#xA;Solution:&#xA;    S ➞ List&#xA;    E ➞ int&#xA;    P ➞ int&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;bound-vs-free-type-parameters&#34;&gt;Bound vs free type parameters&lt;/h3&gt;&#xA;&lt;p&gt;At this point we have a clearer understanding of the various source of type equations,&#xA;but we have not been very precise about which type parameters to solve the equations for.&#xA;Let&amp;rsquo;s consider another example.&#xA;In the code below, the function body of &lt;code&gt;sortedPrint&lt;/code&gt; calls &lt;code&gt;slices.Sort&lt;/code&gt; for the sorting part.&#xA;&lt;code&gt;sortedPrint&lt;/code&gt; and &lt;code&gt;slices.Sort&lt;/code&gt; are generic functions as both declare type parameters.&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;// From the slices package&#xA;// func Sort[S ~[]E, E cmp.Ordered](x S)&#xA;&#xA;// sortedPrint prints the elements of the provided list in sorted order.&#xA;func sortedPrint[F any](list []F) {&#xA;    slices.Sort(list)  // 𝑻(list) is []F&#xA;    …                  // print list&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;We want to infer the type argument for the &lt;code&gt;slices.Sort&lt;/code&gt; call.&#xA;Passing &lt;code&gt;list&lt;/code&gt; to parameter &lt;code&gt;x&lt;/code&gt; of &lt;code&gt;slices.Sort&lt;/code&gt; gives rise to the equation&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;𝑻(x) :≡ 𝑻(list)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;which is the same as&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;S :≡ []F&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;In this equation we have two type parameters, &lt;code&gt;S&lt;/code&gt; and &lt;code&gt;F&lt;/code&gt;.&#xA;Which one do we need to solve the type equation for?&#xA;Because the invoked function is &lt;code&gt;Sort&lt;/code&gt;, we care about its type parameter &lt;code&gt;S&lt;/code&gt;,&#xA;not the type parameter &lt;code&gt;F&lt;/code&gt;.&#xA;We say that &lt;code&gt;S&lt;/code&gt; is &lt;em&gt;bound&lt;/em&gt; to &lt;code&gt;Sort&lt;/code&gt; because it is declared by &lt;code&gt;Sort&lt;/code&gt;.&#xA;&lt;code&gt;S&lt;/code&gt; is the relevant type variable in this equation.&#xA;By contrast, &lt;code&gt;F&lt;/code&gt; is bound to (declared by) &lt;code&gt;sortedPrint&lt;/code&gt;.&#xA;We say that &lt;code&gt;F&lt;/code&gt; is &lt;em&gt;free&lt;/em&gt; with respect to &lt;code&gt;Sort&lt;/code&gt;.&#xA;It has its own, already given type.&#xA;That type is &lt;code&gt;F&lt;/code&gt;, whatever that is (determined at instantiation time).&#xA;In this equation, &lt;code&gt;F&lt;/code&gt; is already given, it is a &lt;em&gt;type constant&lt;/em&gt;.&lt;/p&gt;&#xA;&lt;p&gt;When solving type equations we always solve for the type parameters&#xA;bound to the function we are calling&#xA;(or assigning in case of a generic function assignment).&lt;/p&gt;&#xA;&lt;h2 id=&#34;solving-type-equations&#34;&gt;Solving type equations&lt;/h2&gt;&#xA;&lt;p&gt;The missing piece, now that we have established how to collect the relevant&#xA;type parameters and type equations, is of course the algorithm that allows&#xA;us to solve the equations.&#xA;After the various examples, it probably has become obvious that solving&#xA;&lt;code&gt;X ≡ Y&lt;/code&gt; simply means comparing the types &lt;code&gt;X&lt;/code&gt; and &lt;code&gt;Y&lt;/code&gt; recursively against&#xA;each other, and in the process determining suitable type arguments for&#xA;type parameters that may occur in &lt;code&gt;X&lt;/code&gt; and &lt;code&gt;Y&lt;/code&gt;.&#xA;The goal is to make the types &lt;code&gt;X&lt;/code&gt; and &lt;code&gt;Y&lt;/code&gt; &lt;em&gt;identical&lt;/em&gt;.&#xA;This matching process is called &lt;a href=&#34;https://en.wikipedia.org/wiki/Unification_(computer_science)&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;&lt;em&gt;unification&lt;/em&gt;&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;p&gt;The rules for &lt;a href=&#34;/ref/spec#Type_identity&#34;&gt;type identity&lt;/a&gt; tell&#xA;us how to compare types.&#xA;Since &lt;em&gt;bound&lt;/em&gt; type parameters play the role of type variables, we need&#xA;to specify how they are matched against other types.&#xA;The rules are as follows:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;If type parameter &lt;code&gt;P&lt;/code&gt; has an inferred type, &lt;code&gt;P&lt;/code&gt; stands for that type.&lt;/li&gt;&#xA;&lt;li&gt;If type parameter &lt;code&gt;P&lt;/code&gt; doesn&amp;rsquo;t have an inferred type and is matched against another type&#xA;&lt;code&gt;T&lt;/code&gt;, &lt;code&gt;P&lt;/code&gt; is set to that type: &lt;code&gt;P ➞ T&lt;/code&gt;.&#xA;We say that the type &lt;code&gt;T&lt;/code&gt; was inferred for &lt;code&gt;P&lt;/code&gt;.&lt;/li&gt;&#xA;&lt;li&gt;If &lt;code&gt;P&lt;/code&gt; matches against another type parameter &lt;code&gt;Q&lt;/code&gt;, and neither &lt;code&gt;P&lt;/code&gt; nor &lt;code&gt;Q&lt;/code&gt;&#xA;have an inferred type yet, &lt;code&gt;P&lt;/code&gt; and &lt;code&gt;Q&lt;/code&gt; are &lt;em&gt;unified&lt;/em&gt;.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;Unification of two type parameters means that they are joined together such&#xA;that going forward they both denote the same type parameter value:&#xA;if one of &lt;code&gt;P&lt;/code&gt; or &lt;code&gt;Q&lt;/code&gt; is matched against a type &lt;code&gt;T&lt;/code&gt;, both &lt;code&gt;P&lt;/code&gt; and &lt;code&gt;Q&lt;/code&gt; are&#xA;set to &lt;code&gt;T&lt;/code&gt; simultaneously&#xA;(in general, any number of type parameters may be unified this way).&lt;/p&gt;&#xA;&lt;p&gt;Finally, if two types &lt;code&gt;X&lt;/code&gt; and &lt;code&gt;Y&lt;/code&gt; are different, the equation cannot be made&#xA;true and solving it fails.&lt;/p&gt;&#xA;&lt;h3 id=&#34;unifying-types-for-type-identity&#34;&gt;Unifying types for type identity&lt;/h3&gt;&#xA;&lt;p&gt;A few concrete examples should make this algorithm clear.&#xA;Consider two types &lt;code&gt;X&lt;/code&gt; and &lt;code&gt;Y&lt;/code&gt; containing three bound type parameters &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;, and &lt;code&gt;C&lt;/code&gt;,&#xA;all appearing in the type equation &lt;code&gt;X ≡ Y&lt;/code&gt;.&#xA;The goal is to the solve this equation for the type parameters; i.e., find suitable&#xA;type arguments for them such that &lt;code&gt;X&lt;/code&gt; and &lt;code&gt;Y&lt;/code&gt; become identical and thus the equation&#xA;becomes true.&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;X: map[A]struct{i int; s []B}&#xA;Y: map[string]struct{i C; s []byte}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Unification proceeds by comparing the structure of &lt;code&gt;X&lt;/code&gt; and &lt;code&gt;Y&lt;/code&gt; recursively, starting at the top.&#xA;Simply looking at the structure of the two types we have&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;map[…]… ≡ map[…]…&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;with the &lt;code&gt;…&lt;/code&gt; representing the respective map key and value types that we&amp;rsquo;re&#xA;ignoring at this step.&#xA;Since we have a map on both sides, the types are identical so far.&#xA;Unification proceeds recursively, first with the key types which are &lt;code&gt;A&lt;/code&gt; for the &lt;code&gt;X&lt;/code&gt; map,&#xA;and &lt;code&gt;string&lt;/code&gt; for the &lt;code&gt;Y&lt;/code&gt; map.&#xA;Corresponding key types must be identical, and from that we can immediately infer that&#xA;the type argument for &lt;code&gt;A&lt;/code&gt; must be &lt;code&gt;string&lt;/code&gt;:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;A ≡ string =&amp;gt; A ➞ string&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Continuing with the map element types, we arrive at&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;struct{i int; s []B} ≡ struct{i C; s []byte}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Both sides are structs so unification proceeds with the struct fields.&#xA;They are identical if they are in the same order, with the same names, and identical types.&#xA;The first field pair is &lt;code&gt;i int&lt;/code&gt; and &lt;code&gt;i C&lt;/code&gt;.&#xA;The names match and because &lt;code&gt;int&lt;/code&gt; must unify with &lt;code&gt;C&lt;/code&gt;, thus&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;int ≡ C =&amp;gt; C ➞ int&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;This recursive type matching continues until the tree structure of the two types is fully&#xA;traversed, or until a conflict appears.&#xA;In this example, eventually we end up with&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;[]B ≡ []byte =&amp;gt; B ≡ byte =&amp;gt; B ➞ byte&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Everything works out fine and unification infers the type arguments&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;A ➞ string&#xA;B ➞ byte&#xA;C ➞ int&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;unifying-types-with-different-structures&#34;&gt;Unifying types with different structures&lt;/h3&gt;&#xA;&lt;p&gt;Now, let&amp;rsquo;s consider a slight variation of the previous example:&#xA;here &lt;code&gt;X&lt;/code&gt; and &lt;code&gt;Y&lt;/code&gt; don&amp;rsquo;t have the same type structure.&#xA;When the type trees are compared recursively, unification still successfully infers the type argument for &lt;code&gt;A&lt;/code&gt;.&#xA;But the value types of the maps are different and unification fails.&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;X: map[A]struct{i int; s []B}&#xA;Y: map[string]bool&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Both &lt;code&gt;X&lt;/code&gt; and &lt;code&gt;Y&lt;/code&gt; are map types, so unification proceeds recursively as before, starting with the key types.&#xA;We arrive at&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;A ≡ string =&amp;gt; A ➞ string&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;also as before.&#xA;But when we proceed with the map&amp;rsquo;s value types we have&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;struct{…} ≡ bool&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;The &lt;code&gt;struct&lt;/code&gt; type doesn&amp;rsquo;t match &lt;code&gt;bool&lt;/code&gt;; we have different types and unification (and thus type inference) fails.&lt;/p&gt;&#xA;&lt;h3 id=&#34;unifying-types-with-conflicting-type-arguments&#34;&gt;Unifying types with conflicting type arguments&lt;/h3&gt;&#xA;&lt;p&gt;Another kind of conflict appears when different types match against the same type parameter.&#xA;Here we have again a version of our initial example but now the type parameter &lt;code&gt;A&lt;/code&gt; appears twice in &lt;code&gt;X&lt;/code&gt;,&#xA;and &lt;code&gt;C&lt;/code&gt; appears twice in &lt;code&gt;Y&lt;/code&gt;.&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;X: map[A]struct{i int; s []A}&#xA;Y: map[string]struct{i C; s []C}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;The recursive type unification works out fine at first and we have the following pairings of type&#xA;parameters and types:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;A   ≡ string =&amp;gt; A ➞ string  // map key type&#xA;int ≡ C      =&amp;gt; C ➞ int     // first struct field type&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;When we get to the second struct field type we have&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;[]A ≡ []C =&amp;gt; A ≡ C&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Since both &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;C&lt;/code&gt; have a type argument inferred for them, they stand for those type arguments,&#xA;which are &lt;code&gt;string&lt;/code&gt; and &lt;code&gt;int&lt;/code&gt; respectively.&#xA;These are different types, so &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;C&lt;/code&gt; can&amp;rsquo;t possibly match.&#xA;Unification and thus type inference fails.&lt;/p&gt;&#xA;&lt;h3 id=&#34;other-type-relations&#34;&gt;Other type relations&lt;/h3&gt;&#xA;&lt;p&gt;Unification solves type equations of the form &lt;code&gt;X ≡ Y&lt;/code&gt; where the goal is &lt;em&gt;type identity&lt;/em&gt;.&#xA;But what about &lt;code&gt;X :≡ Y&lt;/code&gt; or &lt;code&gt;X ∈ Y&lt;/code&gt;?&lt;/p&gt;&#xA;&lt;p&gt;A couple of observations help us out here:&#xA;The job of type inference is solely to find the types of omitted type arguments.&#xA;Type inference is always followed by type or function&#xA;&lt;a href=&#34;/ref/spec#Instantiations&#34;&gt;instantiation&lt;/a&gt; which&#xA;checks that each type argument actually satisfies its respective type constraint.&#xA;Finally, in case of a generic function call, the compiler also checks that&#xA;function arguments are assignable to their corresponding function parameters.&#xA;All of these steps must succeed for the code to be valid.&lt;/p&gt;&#xA;&lt;p&gt;If type inference is not precise enough it may infer an (incorrect) type argument&#xA;where no type may exist.&#xA;If that is the case, either instantiation or argument passing will fail.&#xA;Either way, the compiler will produce an error message.&#xA;It&amp;rsquo;s just that the error message may be slightly different.&lt;/p&gt;&#xA;&lt;p&gt;This insight allows us to play a bit loose with the type relations &lt;code&gt;:≡&lt;/code&gt; and &lt;code&gt;∈&lt;/code&gt;.&#xA;Specifically, it allows us to simplify them such that they can be treated&#xA;almost the same as &lt;code&gt;≡&lt;/code&gt;.&#xA;The goal of the simplifications is to extract as much type information as&#xA;possible from a type equation, and thus to infer type arguments where a&#xA;precise implementation may fail, because we can.&lt;/p&gt;&#xA;&lt;h3 id=&#34;simplifying-x--y&#34;&gt;Simplifying X :≡ Y&lt;/h3&gt;&#xA;&lt;p&gt;Go&amp;rsquo;s assignability rules are pretty complicated, but most of the time we can actually&#xA;get by with type identity, or a slight variation of it.&#xA;As long as we find potential type arguments, we&amp;rsquo;re happy, exactly because type inference&#xA;is still followed by type instantiation and function invocation.&#xA;If inference finds a type argument where it shouldn&amp;rsquo;t, it&amp;rsquo;ll be caught later.&#xA;Thus, when matching for assignability, we make the following adjustments to the&#xA;unfication algorithm:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;When a named (defined) type is matched against a type literal,&#xA;their underlying types are compared instead.&lt;/li&gt;&#xA;&lt;li&gt;When comparing channel types, channel directions are ignored.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;Furthermore, the assignment direction is ignored: &lt;code&gt;X :≡ Y&lt;/code&gt; is treated like &lt;code&gt;Y :≡ X&lt;/code&gt;.&lt;/p&gt;&#xA;&lt;p&gt;These adjustments apply only at the top level of a type structure:&#xA;for instance, per Go&amp;rsquo;s &lt;a href=&#34;/ref/spec#Assignability&#34;&gt;assignability rules&lt;/a&gt;,&#xA;a named map type may be assigned to an unnamed map type, but the key and element types&#xA;must still be identical.&#xA;With these changes, unification for assignability becomes a (minor) variation&#xA;of unification for type identity.&#xA;The following example illustrates this.&lt;/p&gt;&#xA;&lt;p&gt;Let&amp;rsquo;s assume we are passing a value of our earlier &lt;code&gt;List&lt;/code&gt; type (defined as &lt;code&gt;type List []int&lt;/code&gt;)&#xA;to a function parameter of type &lt;code&gt;[]E&lt;/code&gt; where &lt;code&gt;E&lt;/code&gt; is a bound type parameter (i.e., &lt;code&gt;E&lt;/code&gt; is declared&#xA;by the generic function that is being called).&#xA;This leads to the type equation &lt;code&gt;[]E :≡ List&lt;/code&gt;.&#xA;Attempting to unify these two types requires comparing &lt;code&gt;[]E&lt;/code&gt; with &lt;code&gt;List&lt;/code&gt;&#xA;These two types are not identical, and without any changes to how unification works,&#xA;it will fail.&#xA;But because we are unifying for assignability, this initial match doesn&amp;rsquo;t need to be exact.&#xA;There&amp;rsquo;s no harm in continuing with the underlying type of the named type &lt;code&gt;List&lt;/code&gt;:&#xA;in the worst case we may infer an incorrect type argument, but that will lead to an error&#xA;later, when assignments are checked.&#xA;In the best case, we find a useful and correct type argument.&#xA;In our example, inexact unification succeeds and we correctly infer &lt;code&gt;int&lt;/code&gt; for &lt;code&gt;E&lt;/code&gt;.&lt;/p&gt;&#xA;&lt;h3 id=&#34;simplifying-x--y-1&#34;&gt;Simplifying X ∈ Y&lt;/h3&gt;&#xA;&lt;p&gt;Being able to simplify the constraint satisfaction relation is even more important as&#xA;constraints can be very complex.&lt;/p&gt;&#xA;&lt;p&gt;Again, constraint satisfaction is checked at instantiation time, so the goal here is&#xA;to help type inference where we can.&#xA;These are typically situations where we know the structure of a type parameter;&#xA;for instance we know that it must be a&#xA;slice type and we care about the slice&amp;rsquo;s element type.&#xA;For example, a type parameter list of the form &lt;code&gt;[P ~[]E]&lt;/code&gt; tells us that whatever &lt;code&gt;P&lt;/code&gt; is,&#xA;its underlying type must be of the form &lt;code&gt;[]E&lt;/code&gt;.&#xA;These are exactly the situations where the constraint has a&#xA;&lt;a href=&#34;/ref/spec#Core_types&#34;&gt;core type&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;p&gt;Therefore, if we have an equation of the form&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;P ∈ constraint               // or&#xA;P ∈ ~constraint&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;and if &lt;code&gt;core(constraint)&lt;/code&gt; (or &lt;code&gt;core(~constraint)&lt;/code&gt;, respectively) exists, the equation&#xA;can be simplified to&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;P        ≡ core(constraint)&#xA;under(P) ≡ core(~constraint)  // respectively&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;In all other cases, type equations involving constraints are ignored.&lt;/p&gt;&#xA;&lt;h3 id=&#34;expanding-inferred-types&#34;&gt;Expanding inferred types&lt;/h3&gt;&#xA;&lt;p&gt;If unification is successful it produces a mapping from type parameters&#xA;to inferred type arguments.&#xA;But unification alone doesn&amp;rsquo;t ensure that the inferred types are free&#xA;of bound type parameters.&#xA;To see why this is the case, consider the generic function &lt;code&gt;g&lt;/code&gt; below&#xA;which is invoked with a single argument &lt;code&gt;x&lt;/code&gt; of type &lt;code&gt;int&lt;/code&gt;:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;func g[A any, B []C, C *A](x A) { … }&#xA;&#xA;var x int&#xA;g(x)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;The type constraint for &lt;code&gt;A&lt;/code&gt; is &lt;code&gt;any&lt;/code&gt; which doesn&amp;rsquo;t have a core type, so we&#xA;ignore it. The remaining type constraints have core types and they are &lt;code&gt;[]C&lt;/code&gt;&#xA;and &lt;code&gt;*A&lt;/code&gt; respectively. Together with the argument passed to &lt;code&gt;g&lt;/code&gt;, after minor&#xA;simplifications, the type equations are:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;    A :≡ int&#xA;    B ≡ []C&#xA;    C ≡ *A&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Since each equation pits a type parameter against a non-type parameter type,&#xA;unification has little to do and immediately infers&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;    A ➞ int&#xA;    B ➞ []C&#xA;    C ➞ *A&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;But that leaves the type parameters &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;C&lt;/code&gt; in the inferred types, which&#xA;is not helpful.&#xA;Like in high school algebra, once an equation is solved for a variable &lt;code&gt;x&lt;/code&gt;,&#xA;we need to substitute &lt;code&gt;x&lt;/code&gt; with its value throughout the remaining equations.&#xA;In our example, in a first step, the &lt;code&gt;C&lt;/code&gt; in &lt;code&gt;[]C&lt;/code&gt; is substituted with the&#xA;inferred type (the &amp;ldquo;value&amp;rdquo;) for &lt;code&gt;C&lt;/code&gt;, which is &lt;code&gt;*A&lt;/code&gt;, and we arrive at&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;    A ➞ int&#xA;    B ➞ []*A    // substituted *A for C&#xA;    C ➞ *A&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;In two more steps we replace the &lt;code&gt;A&lt;/code&gt; in the inferred types &lt;code&gt;[]*A&lt;/code&gt; and &lt;code&gt;*A&lt;/code&gt;&#xA;with the inferred type for &lt;code&gt;A&lt;/code&gt;, which is &lt;code&gt;int&lt;/code&gt;:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;    A ➞ int&#xA;    B ➞ []*int  // substituted int for A&#xA;    C ➞ *int    // substituted int for A&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Only now inference is done.&#xA;And like in high school algebra, sometimes this doesn&amp;rsquo;t work.&#xA;It&amp;rsquo;s possible to arrive at a situation such as&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;    X ➞ Y&#xA;    Y ➞ *X&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;After one round of substitutions we have&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;    X ➞ *X&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;If we keep going, the inferred type for &lt;code&gt;X&lt;/code&gt; keeps growing:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;    X ➞ **X     // substituted *X for X&#xA;    X ➞ ***X    // substituted *X for X&#xA;    etc.&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Type inference detects such cycles during expansion and reports&#xA;an error (and thus fails).&lt;/p&gt;&#xA;&lt;h2 id=&#34;untyped-constants&#34;&gt;Untyped constants&lt;/h2&gt;&#xA;&lt;p&gt;By now we have seen how type inference works by solving type equations&#xA;with unification, followed by expansion of the result.&#xA;But what if there are no types?&#xA;What if the function arguments are untyped constants?&lt;/p&gt;&#xA;&lt;p&gt;Another example helps us shed light on this situation.&#xA;Let&amp;rsquo;s consider a function &lt;code&gt;foo&lt;/code&gt; which takes an arbitrary number of arguments,&#xA;all of which must have the same type.&#xA;&lt;code&gt;foo&lt;/code&gt; is called with a variety of untyped constant arguments, including a variable&#xA;&lt;code&gt;x&lt;/code&gt; of type &lt;code&gt;int&lt;/code&gt;:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;func foo[P any](...P) {}&#xA;&#xA;var x int&#xA;foo(x)         // P ➞ int, same as foo[int](x)&#xA;foo(x, 2.0)    // P ➞ int, 2.0 converts to int without loss of precision&#xA;foo(x, 2.1)    // P ➞ int, but parameter passing fails: 2.1 is not assignable to int&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;For type inference, typed arguments take precedence over untyped arguments.&#xA;An untyped constant is considered for inference only if the type parameter it&amp;rsquo;s assigned&#xA;to doesn&amp;rsquo;t have an inferred type yet.&#xA;In these first three calls to &lt;code&gt;foo&lt;/code&gt;, the variable &lt;code&gt;x&lt;/code&gt; determines the inferred type for &lt;code&gt;P&lt;/code&gt;:&#xA;it&amp;rsquo;s the type of &lt;code&gt;x&lt;/code&gt; which is &lt;code&gt;int&lt;/code&gt;.&#xA;Untyped constants are ignored for type inference in this case and the calls behave exactly&#xA;as if &lt;code&gt;foo&lt;/code&gt; was explicitly instantiated with &lt;code&gt;int&lt;/code&gt;.&lt;/p&gt;&#xA;&lt;p&gt;It gets more interesting if &lt;code&gt;foo&lt;/code&gt; is called with untyped constant arguments only.&#xA;In this case, type inference considers the &lt;a href=&#34;/ref/spec#Constants&#34;&gt;default types&lt;/a&gt;&#xA;of the untyped constants.&#xA;As a quick reminder, here are the possible default types in Go:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;Example     Constant kind              Default type    Order&#xA;&#xA;true        boolean constant           bool&#xA;42          integer constant           int             earlier in list&#xA;&#39;x&#39;         rune constant              rune               |&#xA;3.1416      floating-point constant    float64            v&#xA;-1i         complex constant           complex128      later in list&#xA;&amp;quot;gopher&amp;quot;    string constant            string&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;With this information in hand, let&amp;rsquo;s consider the function call&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;foo(1, 2)    // P ➞ int (default type for 1 and 2)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;The untyped constant arguments &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;2&lt;/code&gt; are both integer constants, their default type is&#xA;&lt;code&gt;int&lt;/code&gt; and thus it&amp;rsquo;s &lt;code&gt;int&lt;/code&gt; that is inferred for the type parameter &lt;code&gt;P&lt;/code&gt; of &lt;code&gt;foo&lt;/code&gt;.&lt;/p&gt;&#xA;&lt;p&gt;If different constants—say untyped integer and floating-point constants—compete&#xA;for the same type variable, we have different default types.&#xA;Before Go 1.21, this was considered a conflict and led to an error:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;foo(1, 2.0)    // Go 1.20: inference error: default types int, float64 don&#39;t match&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;This behavior was not very ergonomic in use and also different from the behavior of untyped constants&#xA;in expressions. For instance, Go permits the constant expression &lt;code&gt;1 + 2.0&lt;/code&gt;;&#xA;the result is the floating-point constant &lt;code&gt;3.0&lt;/code&gt; with default type &lt;code&gt;float64&lt;/code&gt;.&lt;/p&gt;&#xA;&lt;p&gt;In Go 1.21 the behavior was changed accordingly.&#xA;Now, if multiple untyped numeric constants are matched against the same type parameter,&#xA;the default type that appears later in the list of &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;rune&lt;/code&gt;, &lt;code&gt;float64&lt;/code&gt;, &lt;code&gt;complex&lt;/code&gt; is&#xA;selected, matching the rules for &lt;a href=&#34;/ref/spec#Constant_expressions&#34;&gt;constant expressions&lt;/a&gt;:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;foo(1, 2.0)    // Go 1.21: P ➞ float64 (larger default type of 1 and 2.0; behavior like in 1 + 2.0)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;special-situations&#34;&gt;Special situations&lt;/h2&gt;&#xA;&lt;p&gt;By now we&amp;rsquo;ve got the big picture about type inference.&#xA;But there are a couple of important special situations that deserve some attention.&lt;/p&gt;&#xA;&lt;h3 id=&#34;parameter-order-dependencies&#34;&gt;Parameter order dependencies&lt;/h3&gt;&#xA;&lt;p&gt;The first one has to do with parameter order dependencies.&#xA;An important property we want from type inference is that the same types are inferred&#xA;irrespective of the order of the function parameters (and corresponding argument&#xA;order in each call of that function).&lt;/p&gt;&#xA;&lt;p&gt;Let&amp;rsquo;s reconsider our variadic &lt;code&gt;foo&lt;/code&gt; function:&#xA;the type inferred for &lt;code&gt;P&lt;/code&gt; should be the same irrespective of the order in which&#xA;we pass the arguments &lt;code&gt;s&lt;/code&gt; and &lt;code&gt;t&lt;/code&gt; (&lt;a href=&#34;/play/p/sOlWutKnDFc&#34;&gt;playground&lt;/a&gt;).&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;func foo[P any](...P) (x P) {}&#xA;&#xA;type T struct{}&#xA;&#xA;func main() {&#xA;    var s struct{}&#xA;    var t T&#xA;    fmt.Printf(&amp;quot;%T\n&amp;quot;, foo(s, t))&#xA;    fmt.Printf(&amp;quot;%T\n&amp;quot;, foo(t, s)) // expect same result independent of parameter order&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;From the calls to &lt;code&gt;foo&lt;/code&gt; we can extract the relevant type equations:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;𝑻(x) :≡ 𝑻(s) =&amp;gt; P :≡ struct{}    // equation 1&#xA;𝑻(x) :≡ 𝑻(t) =&amp;gt; P :≡ T           // equation 2&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Sadly, the simplified implementation for &lt;code&gt;:≡&lt;/code&gt; produces an order dependency:&lt;/p&gt;&#xA;&lt;p&gt;If unification starts with equation 1, it matches &lt;code&gt;P&lt;/code&gt; against &lt;code&gt;struct&lt;/code&gt;; &lt;code&gt;P&lt;/code&gt; doesn&amp;rsquo;t have a type inferred for it yet&#xA;and thus unification infers &lt;code&gt;P ➞ struct{}&lt;/code&gt;.&#xA;When unification sees type &lt;code&gt;T&lt;/code&gt; later in equation 2, it proceeds with the underlying type of &lt;code&gt;T&lt;/code&gt; which is &lt;code&gt;struct{}&lt;/code&gt;,&#xA;&lt;code&gt;P&lt;/code&gt; and &lt;code&gt;under(T)&lt;/code&gt; unify, and unification and thus inference succeeds.&lt;/p&gt;&#xA;&lt;p&gt;Vice versa, if unification starts with equation 2, it matches &lt;code&gt;P&lt;/code&gt; against &lt;code&gt;T&lt;/code&gt;; &lt;code&gt;P&lt;/code&gt; doesn&amp;rsquo;t have a type inferred for it yet&#xA;and thus unification infers &lt;code&gt;P ➞ T&lt;/code&gt;.&#xA;When unification sees &lt;code&gt;struct{}&lt;/code&gt; later in equation 1, it proceeds with the underlying type of the type &lt;code&gt;T&lt;/code&gt; inferred for &lt;code&gt;P&lt;/code&gt;.&#xA;That underlying type is &lt;code&gt;struct{}&lt;/code&gt;, which matches &lt;code&gt;struct&lt;/code&gt; in equation 1, and unification and thus inference succeeds.&lt;/p&gt;&#xA;&lt;p&gt;As a consequence, depending on the order in which unification solves the two type equations,&#xA;the inferred type is either &lt;code&gt;struct{}&lt;/code&gt; or &lt;code&gt;T&lt;/code&gt;.&#xA;This is of course unsatisfying: a program may suddenly stop compiling simply because arguments&#xA;may have been shuffled around during a code refactoring or cleanup.&lt;/p&gt;&#xA;&lt;h3 id=&#34;restoring-order-independence&#34;&gt;Restoring order independence&lt;/h3&gt;&#xA;&lt;p&gt;Luckily, the remedy is fairly simple.&#xA;All we need is a small correction in some situations.&lt;/p&gt;&#xA;&lt;p&gt;Specifically, if unification is solving &lt;code&gt;P :≡ T&lt;/code&gt; and&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;P&lt;/code&gt; is a type parameter which already has inferred a type &lt;code&gt;A&lt;/code&gt;: &lt;code&gt;P ➞ A&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;A :≡ T&lt;/code&gt; is true&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;T&lt;/code&gt; is a named type&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;then set the inferred type for &lt;code&gt;P&lt;/code&gt; to &lt;code&gt;T&lt;/code&gt;: &lt;code&gt;P ➞ T&lt;/code&gt;&lt;/p&gt;&#xA;&lt;p&gt;This ensures that &lt;code&gt;P&lt;/code&gt; is the named type if there is choice, no matter at which point the named type&#xA;appeared in a match against &lt;code&gt;P&lt;/code&gt; (i.e., no matter in which order the type equations are solved).&#xA;Note that if different named types match against the same type parameter, we always have a unfication&#xA;failure because different named types are not identical by definition.&lt;/p&gt;&#xA;&lt;p&gt;Because we made similar simplifications for channels and interfaces, they also need similar special&#xA;handling. For instance, we ignore channel directions when unifying for assignability and as a result&#xA;may infer a directed or bidirectional channel depending on argument order. Similar problems occur&#xA;with interfaces. We&amp;rsquo;re not going to discuss these here.&lt;/p&gt;&#xA;&lt;p&gt;Going back to our example, if unification starts with equation 1, it infers &lt;code&gt;P ➞ struct{}&lt;/code&gt; as before.&#xA;When it proceeds with equation 2, as before, unification succeeds, but now we have exactly the&#xA;condition that calls for a correction: &lt;code&gt;P&lt;/code&gt; is a type parameter which already has a type (&lt;code&gt;struct{}&lt;/code&gt;),&#xA;&lt;code&gt;struct{}&lt;/code&gt;, &lt;code&gt;struct{} :≡ T&lt;/code&gt; is true (because &lt;code&gt;struct{} ≡ under(T)&lt;/code&gt; is true), and &lt;code&gt;T&lt;/code&gt; is a named type.&#xA;Thus, unification makes the correction and sets &lt;code&gt;P ➞ T&lt;/code&gt;.&#xA;As a result, irrespective of the unification order, the result is the same (&lt;code&gt;T&lt;/code&gt;) in both cases.&lt;/p&gt;&#xA;&lt;h3 id=&#34;self-recursive-functions&#34;&gt;Self-recursive functions&lt;/h3&gt;&#xA;&lt;p&gt;Another scenario that causes problems in a naive implementation of inference is self-recursive functions.&#xA;Let&amp;rsquo;s consider a generic factorial function &lt;code&gt;fact&lt;/code&gt;, defined such that it also works for floating-point arguments&#xA;(&lt;a href=&#34;/play/p/s3wXpgHX6HQ&#34;&gt;playground&lt;/a&gt;).&#xA;Note that this is not a mathematically correct implementation of the&#xA;&lt;a href=&#34;https://en.wikipedia.org/wiki/Gamma_function&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;gamma function&lt;/a&gt;,&#xA;it is simply a convenient example.&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;func fact[P ~int | ~float64](n P) P {&#xA;    if n &amp;lt;= 1 {&#xA;        return 1&#xA;    }&#xA;    return fact(n-1) * n&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;The point here is not the factorial function but rather that &lt;code&gt;fact&lt;/code&gt; calls itself with the&#xA;argument &lt;code&gt;n-1&lt;/code&gt; which is of the same type &lt;code&gt;P&lt;/code&gt; as the incoming parameter &lt;code&gt;n&lt;/code&gt;.&#xA;In this call, the type parameter &lt;code&gt;P&lt;/code&gt; is simultaneously a bound and a free type parameter:&#xA;it is bound because it is declared by &lt;code&gt;fact&lt;/code&gt;, the function that we are calling recursively.&#xA;But it is also free because it is declared by the function enclosing the call, which happens&#xA;to also be &lt;code&gt;fact&lt;/code&gt;.&lt;/p&gt;&#xA;&lt;p&gt;The equation resulting from passing the argument &lt;code&gt;n-1&lt;/code&gt; to parameter &lt;code&gt;n&lt;/code&gt; pits &lt;code&gt;P&lt;/code&gt; against itself:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;𝑻(n) :≡ 𝑻(n-1) =&amp;gt; P :≡ P&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Unification sees the same &lt;code&gt;P&lt;/code&gt; on either side of the equation.&#xA;Unification succeeds since both types are identical but there&amp;rsquo;s no information gained and &lt;code&gt;P&lt;/code&gt;&#xA;remains without an inferred type. As a consequence, type inference fails.&lt;/p&gt;&#xA;&lt;p&gt;Luckily, the trick to address this is simple:&#xA;Before type inference is invoked, and for (temporary) use by type inference only,&#xA;the compiler renames the type parameters in the signatures (but not the bodies)&#xA;of all functions involved in the respective call.&#xA;This doesn&amp;rsquo;t change the meaning of the function signatures:&#xA;they denote the same generic functions irrespective of what the names of the type parameters are.&lt;/p&gt;&#xA;&lt;p&gt;For the purpose of this example, let&amp;rsquo;s assume the &lt;code&gt;P&lt;/code&gt; in the signature of &lt;code&gt;fact&lt;/code&gt; got renamed to &lt;code&gt;Q&lt;/code&gt;.&#xA;The effect is as if the recursive call was done indirectly through a &lt;code&gt;helper&lt;/code&gt; function&#xA;(&lt;a href=&#34;/play/p/TLpo-0auWwC&#34;&gt;playground&lt;/a&gt;):&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;func fact[P ~int | ~float64](n P) P {&#xA;    if n &amp;lt;= 1 {&#xA;        return 1&#xA;    }&#xA;    return helper(n-1) * n&#xA;}&#xA;&#xA;func helper[Q ~int | ~float64](n Q) Q {&#xA;    return fact(n)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;With the renaming, or with the &lt;code&gt;helper&lt;/code&gt; function, the equation resulting from passing&#xA;&lt;code&gt;n-1&lt;/code&gt; to the recursive call of &lt;code&gt;fact&lt;/code&gt; (or the &lt;code&gt;helper&lt;/code&gt; function, respectively) changes&#xA;to&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;𝑻(n) :≡ 𝑻(n-1) =&amp;gt; Q :≡ P&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;This equation has two type parameters: the bound type parameter &lt;code&gt;Q&lt;/code&gt;, declared by the&#xA;function that is being called, and the free type parameter &lt;code&gt;P&lt;/code&gt;, declared by the enclosing&#xA;function. This type equation is trivially solved for &lt;code&gt;Q&lt;/code&gt; and results in the inference&#xA;&lt;code&gt;Q ➞ P&lt;/code&gt;&#xA;which is of course what we&amp;rsquo;d expect, and which we can verify by explicitly instantiating&#xA;the recursive call (&lt;a href=&#34;/play/p/zkUFvwJ54lC&#34;&gt;playground&lt;/a&gt;):&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;func fact[P ~int | ~float64](n P) P {&#xA;    if n &amp;lt;= 1 {&#xA;        return 1&#xA;    }&#xA;    return fact[P](n-1) * n&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;whats-missing&#34;&gt;What&amp;rsquo;s missing?&lt;/h2&gt;&#xA;&lt;p&gt;Conspicuously absent from our description is type inference for generic types:&#xA;currently generic types must always be explicitly instantiated.&lt;/p&gt;&#xA;&lt;p&gt;There are a couple of reasons for this. First of all, for type instantiation, type inference&#xA;only has type arguments to work with; there are no other arguments as is the case for&#xA;function calls. As a consequence, at least one type argument must always be provided&#xA;(except for pathological cases where type constraints prescribe exactly one possible&#xA;type argument for all type parameters).&#xA;Thus, type inference for types is only useful to complete a partially&#xA;instantiated type where all the omitted type arguments can be inferred from the&#xA;equations resulting from type constraints; i.e., where there are at least two type&#xA;parameters. We believe this is not a very common scenario.&lt;/p&gt;&#xA;&lt;p&gt;Second, and more pertinent, type parameters allow an entirely new kind of recursive&#xA;types. Consider the hypothetical type&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;type T[P T[P]] interface{ … }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;where the constraint for &lt;code&gt;P&lt;/code&gt; is the type being declared.&#xA;Combined with the ablity to have multiple type parameters that may refer to each other&#xA;in complex recursive fashion, type inference becomes much more complicated and we don&amp;rsquo;t&#xA;fully understand all the implications of that at the moment.&#xA;That said, we believe it shouldn&amp;rsquo;t be too hard to detect cycles and proceed with&#xA;type inference where no such cycles exist.&lt;/p&gt;&#xA;&lt;p&gt;Finally, there are situations where type inference is simply not strong enough to make&#xA;an inference, typically because unification works with certain simplifying assumptions&#xA;such as the ones described earlier in this post.&#xA;The primary example here is constraints which have no core type,&#xA;but where a more sophisticated approach might be able to infer type information anyway.&lt;/p&gt;&#xA;&lt;p&gt;These are all areas where we may see incremental improvements in future Go releases.&#xA;Importantly, we believe that cases where inference currently fails are either rare&#xA;or unimportant in production code, and that our current implementation covers a large&#xA;majority of all useful code scenarios.&lt;/p&gt;&#xA;&lt;p&gt;That said, if you run into a situation where you believe type inference should work or&#xA;went astray, please &lt;a href=&#34;/issue/new&#34;&gt;file an issue&lt;/a&gt;!&#xA;As always, the Go team loves to hear from you, especially when it helps us making Go&#xA;even better.&lt;/p&gt;&#xA;&#xA;    &lt;/div&gt;&#xA;&#xA;    &#xA;    &lt;div class=&#34;Article prevnext&#34;&gt;&#xA;    &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;        &lt;p&gt;&#xA;        &#xA;          &#xA;            &lt;b&gt;Next article: &lt;/b&gt;&lt;a href=&#34;/blog/14years&#34;&gt;Fourteen Years of Go&lt;/a&gt;&lt;br&gt;&#xA;          &#xA;        &#xA;        &#xA;          &#xA;            &lt;b&gt;Previous article: &lt;/b&gt;&lt;a href=&#34;/blog/deconstructing-type-parameters&#34;&gt;Deconstructing Type Parameters&lt;/a&gt;&lt;br&gt;&#xA;          &#xA;        &#xA;        &lt;b&gt;&lt;a href=&#34;/blog/all&#34;&gt;Blog Index&lt;/a&gt;&lt;/b&gt;&#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;    &lt;/div&gt;&#xA;    &#xA;&#xA;  &lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;script src=&#34;/js/jquery.js&#34;&gt;&lt;/script&gt;&#xA;&lt;script src=&#34;/js/playground.js&#34;&gt;&lt;/script&gt;&#xA;&lt;script src=&#34;/js/play.js&#34;&gt;&lt;/script&gt;&#xA;&lt;script src=&#34;/js/godocs.js&#34;&gt;&lt;/script&gt;&#xA;&#xA;</content></entry><entry><title>Deconstructing Type Parameters</title><id>tag:blog.golang.org,2013:blog.golang.org/deconstructing-type-parameters</id><link rel="alternate" href="https://go.dev/blog/deconstructing-type-parameters"></link><published>2023-09-26T00:00:00+00:00</published><updated>2023-09-26T00:00:00+00:00</updated><author><name></name></author><summary type="html">Why the function signatures in the slices packages are so complicated.</summary><content type="html">&#xA;&lt;div id=&#34;blog&#34;&gt;&lt;div id=&#34;content&#34;&gt;&#xA;  &lt;div id=&#34;content&#34;&gt;&#xA;&#xA;    &lt;div class=&#34;Article&#34; data-slug=&#34;/blog/deconstructing-type-parameters&#34;&gt;&#xA;    &#xA;    &lt;h1 class=&#34;small&#34;&gt;&lt;a href=&#34;/blog/&#34;&gt;The Go Blog&lt;/a&gt;&lt;/h1&gt;&#xA;    &#xA;&#xA;    &lt;h1&gt;Deconstructing Type Parameters&lt;/h1&gt;&#xA;      &#xA;      &lt;p class=&#34;author&#34;&gt;&#xA;      Ian Lance Taylor&lt;br&gt;&#xA;      26 September 2023&#xA;      &lt;/p&gt;&#xA;      &#xA;      &lt;h2 id=&#34;slices-package-function-signatures&#34;&gt;slices package function signatures&lt;/h2&gt;&#xA;&lt;p&gt;The &lt;a href=&#34;https://pkg.go.dev/slices#Clone&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;slices.Clone&lt;/code&gt;&lt;/a&gt; function is&#xA;pretty simple: it makes a copy of a slice of any type.&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;func Clone[S ~[]E, E any](s S) S {&#xA;    return append(s[:0:0], s...)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;This works because appending to a slice with zero capacity will&#xA;allocate a new backing array.&#xA;The function body winds up being shorter than the function signature,&#xA;which is in part because the body is short, but also because the&#xA;signature is long.&#xA;In this blog post we&amp;rsquo;ll explain why the signature is written the way&#xA;that it is.&lt;/p&gt;&#xA;&lt;h2 id=&#34;simple-clone&#34;&gt;Simple Clone&lt;/h2&gt;&#xA;&lt;p&gt;We&amp;rsquo;ll start by writing a simple generic &lt;code&gt;Clone&lt;/code&gt; function.&#xA;This is not the one in the &lt;code&gt;slices&lt;/code&gt; package.&#xA;We want to take a slice of any element type, and return a new slice.&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;func Clone1[E any](s []E) []E {&#xA;    // body omitted&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;The generic function &lt;code&gt;Clone1&lt;/code&gt; has a single type parameter &lt;code&gt;E&lt;/code&gt;.&#xA;It takes a single argument &lt;code&gt;s&lt;/code&gt; which is a slice of type &lt;code&gt;E&lt;/code&gt;, and it&#xA;returns a slice of the same type.&#xA;This signature is straightforward for anybody familiar with generics&#xA;in Go.&lt;/p&gt;&#xA;&lt;p&gt;However, there is a problem.&#xA;Named slice types are not common in Go, but people do use them.&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;// MySlice is a slice of strings with a special String method.&#xA;type MySlice []string&#xA;&#xA;// String returns the printable version of a MySlice value.&#xA;func (s MySlice) String() string {&#xA;    return strings.Join(s, &amp;quot;+&amp;quot;)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Let&amp;rsquo;s say that we want to make a copy of a &lt;code&gt;MySlice&lt;/code&gt; and then get the&#xA;printable version, but with the strings in sorted order.&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;func PrintSorted(ms MySlice) string {&#xA;    c := Clone1(ms)&#xA;    slices.Sort(c)&#xA;    return c.String() // FAILS TO COMPILE&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Unfortunately, this doesn&amp;rsquo;t work.&#xA;The compiler reports an error:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;c.String undefined (type []string has no field or method String)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;We can see the problem if we manually instantiate &lt;code&gt;Clone1&lt;/code&gt; by&#xA;replacing the type parameter with the type argument.&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;func InstantiatedClone1(s []string) []string&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;The &lt;a href=&#34;/ref/spec#Assignability&#34;&gt;Go assignment rules&lt;/a&gt; allow&#xA;us to pass a value of type &lt;code&gt;MySlice&lt;/code&gt; to a parameter of type&#xA;&lt;code&gt;[]string&lt;/code&gt;, so calling &lt;code&gt;Clone1&lt;/code&gt; is fine.&#xA;But &lt;code&gt;Clone1&lt;/code&gt; will return a value of type &lt;code&gt;[]string&lt;/code&gt;, not a value of&#xA;type &lt;code&gt;MySlice&lt;/code&gt;.&#xA;The type &lt;code&gt;[]string&lt;/code&gt; doesn&amp;rsquo;t have a &lt;code&gt;String&lt;/code&gt; method, so the compiler&#xA;reports an error.&lt;/p&gt;&#xA;&lt;h2 id=&#34;flexible-clone&#34;&gt;Flexible Clone&lt;/h2&gt;&#xA;&lt;p&gt;To fix this problem, we have to write a version of &lt;code&gt;Clone&lt;/code&gt; that&#xA;returns the same type as its argument.&#xA;If we can do that, then when we call &lt;code&gt;Clone&lt;/code&gt; with a value of type&#xA;&lt;code&gt;MySlice&lt;/code&gt;, it will return a result of type &lt;code&gt;MySlice&lt;/code&gt;.&lt;/p&gt;&#xA;&lt;p&gt;We know that it has to look something like this.&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;func Clone2[S ?](s S) S // INVALID&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;This &lt;code&gt;Clone2&lt;/code&gt; function returns a value that is the same type as its&#xA;argument.&lt;/p&gt;&#xA;&lt;p&gt;Here I&amp;rsquo;ve written the constraint as &lt;code&gt;?&lt;/code&gt;, but that&amp;rsquo;s just a&#xA;placeholder.&#xA;To make this work we need to write a constraint that will let us write&#xA;the body of the function.&#xA;For &lt;code&gt;Clone1&lt;/code&gt; we could just use a constraint of &lt;code&gt;any&lt;/code&gt; for the element&#xA;type.&#xA;For &lt;code&gt;Clone2&lt;/code&gt; that won&amp;rsquo;t work: we want to require that &lt;code&gt;s&lt;/code&gt; be a slice&#xA;type.&lt;/p&gt;&#xA;&lt;p&gt;Since we know we want a slice, the constraint of &lt;code&gt;S&lt;/code&gt; has to be a&#xA;slice.&#xA;We don&amp;rsquo;t care what the slice element type is, so let&amp;rsquo;s just call it&#xA;&lt;code&gt;E&lt;/code&gt;, as we did with &lt;code&gt;Clone1&lt;/code&gt;.&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;func Clone3[S []E](s S) S // INVALID&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;This is still invalid, because we haven&amp;rsquo;t declared &lt;code&gt;E&lt;/code&gt;.&#xA;The type argument for &lt;code&gt;E&lt;/code&gt; can be any type, which means it also has to&#xA;be a type parameter itself.&#xA;Since it can be any type, its constraint is &lt;code&gt;any&lt;/code&gt;.&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;func Clone4[S []E, E any](s S) S&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;This is getting close, and at least it will compile, but we&amp;rsquo;re not&#xA;quite there yet.&#xA;If we compile this version, we get an error when we call &lt;code&gt;Clone4(ms)&lt;/code&gt;.&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;MySlice does not satisfy []string (possibly missing ~ for []string in []string)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;The compiler is telling us that we can&amp;rsquo;t use the type argument&#xA;&lt;code&gt;MySlice&lt;/code&gt; for the type parameter &lt;code&gt;S&lt;/code&gt;, because &lt;code&gt;MySlice&lt;/code&gt; does not&#xA;satisfy the constraint &lt;code&gt;[]E&lt;/code&gt;.&#xA;That&amp;rsquo;s because &lt;code&gt;[]E&lt;/code&gt; as a constraint only permits a slice type&#xA;literal, like &lt;code&gt;[]string&lt;/code&gt;.&#xA;It doesn&amp;rsquo;t permit a named type like &lt;code&gt;MySlice&lt;/code&gt;.&lt;/p&gt;&#xA;&lt;h2 id=&#34;underlying-type-constraints&#34;&gt;Underlying type constraints&lt;/h2&gt;&#xA;&lt;p&gt;As the error message hints, the answer is to add a &lt;code&gt;~&lt;/code&gt;.&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;func Clone5[S ~[]E, E any](s S) S&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;To repeat, writing type parameters and constraints &lt;code&gt;[S []E, E any]&lt;/code&gt;&#xA;means that the type argument for &lt;code&gt;S&lt;/code&gt; can be any unnamed slice type,&#xA;but it can&amp;rsquo;t be a named type defined as a slice literal.&#xA;Writing &lt;code&gt;[S ~[]E, E any]&lt;/code&gt;, with a &lt;code&gt;~&lt;/code&gt;, means that the type argument&#xA;for &lt;code&gt;S&lt;/code&gt; can be any type whose underlying type is a slice type.&lt;/p&gt;&#xA;&lt;p&gt;For any named type &lt;code&gt;type T1 T2&lt;/code&gt; the underlying type of &lt;code&gt;T1&lt;/code&gt; is the&#xA;underlying type of &lt;code&gt;T2&lt;/code&gt;.&#xA;The underlying type of a predeclared type like &lt;code&gt;int&lt;/code&gt; or a type literal&#xA;like &lt;code&gt;[]string&lt;/code&gt; is just the type itself.&#xA;For the exact details, &lt;a href=&#34;/ref/spec#Underlying_types&#34;&gt;see the language&#xA;spec&lt;/a&gt;.&#xA;In our example, the underlying type of &lt;code&gt;MySlice&lt;/code&gt; is &lt;code&gt;[]string&lt;/code&gt;.&lt;/p&gt;&#xA;&lt;p&gt;Since the underlying type of &lt;code&gt;MySlice&lt;/code&gt; is a slice, we can pass an&#xA;argument of type &lt;code&gt;MySlice&lt;/code&gt; to &lt;code&gt;Clone5&lt;/code&gt;.&#xA;As you may have noticed, the signature of &lt;code&gt;Clone5&lt;/code&gt; is the same as the&#xA;signature of &lt;code&gt;slices.Clone&lt;/code&gt;.&#xA;We&amp;rsquo;ve finally gotten to where we want to be.&lt;/p&gt;&#xA;&lt;p&gt;Before we move on, let&amp;rsquo;s discuss why the Go syntax requires a &lt;code&gt;~&lt;/code&gt;.&#xA;It might seem that we would always want to permit passing &lt;code&gt;MySlice&lt;/code&gt;,&#xA;so why not make that the default?&#xA;Or, if we need to support exact matching, why not flip things around,&#xA;so that a constraint of &lt;code&gt;[]E&lt;/code&gt; permits a named type while a constraint&#xA;of, say, &lt;code&gt;=[]E&lt;/code&gt;, only permits slice type literals?&lt;/p&gt;&#xA;&lt;p&gt;To explain this, let&amp;rsquo;s first observe that a type parameter list like&#xA;&lt;code&gt;[T ~MySlice]&lt;/code&gt; doesn&amp;rsquo;t make sense.&#xA;That&amp;rsquo;s because &lt;code&gt;MySlice&lt;/code&gt; is not the underlying type of any other type.&#xA;For instance, if we have a definition like &lt;code&gt;type MySlice2 MySlice&lt;/code&gt;,&#xA;the underlying type of &lt;code&gt;MySlice2&lt;/code&gt; is &lt;code&gt;[]string&lt;/code&gt;, not &lt;code&gt;MySlice&lt;/code&gt;.&#xA;So either &lt;code&gt;[T ~MySlice]&lt;/code&gt; would permit no types at all, or it would be&#xA;the same as &lt;code&gt;[T MySlice]&lt;/code&gt; and only match &lt;code&gt;MySlice&lt;/code&gt;.&#xA;Either way, &lt;code&gt;[T ~MySlice]&lt;/code&gt; isn&amp;rsquo;t useful.&#xA;To avoid this confusion, the language prohibits &lt;code&gt;[T ~MySlice]&lt;/code&gt;, and&#xA;the compiler produces an error like&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;invalid use of ~ (underlying type of MySlice is []string)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;If Go didn&amp;rsquo;t require the tilde, so that &lt;code&gt;[S []E]&lt;/code&gt; would match any type&#xA;whose underlying type is &lt;code&gt;[]E&lt;/code&gt;, then we would have to define the&#xA;meaning of &lt;code&gt;[S MySlice]&lt;/code&gt;.&lt;/p&gt;&#xA;&lt;p&gt;We could prohibit &lt;code&gt;[S MySlice]&lt;/code&gt;, or we could say that &lt;code&gt;[S MySlice]&lt;/code&gt;&#xA;only matches &lt;code&gt;MySlice&lt;/code&gt;, but either approach runs into trouble with&#xA;predeclared types.&#xA;A predeclared type, like &lt;code&gt;int&lt;/code&gt; is its own underlying type.&#xA;We want to permit people to be able to write constraints that accept&#xA;any type argument whose underlying type is &lt;code&gt;int&lt;/code&gt;.&#xA;In the language today, they can do that by writing &lt;code&gt;[T ~int]&lt;/code&gt;.&#xA;If we don&amp;rsquo;t require the tilde we would still need a way to say &amp;ldquo;any&#xA;type whose underlying type is &lt;code&gt;int&lt;/code&gt;&amp;rdquo;.&#xA;The natural way to say that would be &lt;code&gt;[T int]&lt;/code&gt;.&#xA;That would mean that &lt;code&gt;[T MySlice]&lt;/code&gt; and &lt;code&gt;[T int]&lt;/code&gt; would behave&#xA;differently, although they look very similar.&lt;/p&gt;&#xA;&lt;p&gt;We could perhaps say that &lt;code&gt;[S MySlice]&lt;/code&gt; matches any type whose&#xA;underlying type is the underlying type of &lt;code&gt;MySlice&lt;/code&gt;, but that makes&#xA;&lt;code&gt;[S MySlice]&lt;/code&gt; unnecessary and confusing.&lt;/p&gt;&#xA;&lt;p&gt;We think it&amp;rsquo;s better to require the &lt;code&gt;~&lt;/code&gt; and be very clear about when&#xA;we are matching the underlying type rather than the type itself.&lt;/p&gt;&#xA;&lt;h2 id=&#34;type-inference&#34;&gt;Type inference&lt;/h2&gt;&#xA;&lt;p&gt;Now that we&amp;rsquo;ve explained the signature of &lt;code&gt;slices.Clone&lt;/code&gt;, let&amp;rsquo;s see&#xA;how actually using &lt;code&gt;slices.Clone&lt;/code&gt; is simplified by type inference.&#xA;Remember, the signature of &lt;code&gt;Clone&lt;/code&gt; is&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;func Clone[S ~[]E, E any](s S) S&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;A call of &lt;code&gt;slices.Clone&lt;/code&gt; will pass a slice to the parameter &lt;code&gt;s&lt;/code&gt;.&#xA;Simple type inference will let the compiler infer that the type&#xA;argument for the type parameter &lt;code&gt;S&lt;/code&gt; is the type of the slice being&#xA;passed to &lt;code&gt;Clone&lt;/code&gt;.&#xA;Type inference is then powerful enough to see that the type argument&#xA;for &lt;code&gt;E&lt;/code&gt; is the element type of the type argument passed to &lt;code&gt;S&lt;/code&gt;.&lt;/p&gt;&#xA;&lt;p&gt;This means that we can write&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;    c := Clone(ms)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;without having to write&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;    c := Clone[MySlice, string](ms)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;If we refer to &lt;code&gt;Clone&lt;/code&gt; without calling it, we do have to specify a&#xA;type argument for &lt;code&gt;S&lt;/code&gt;, as the compiler has nothing it can use to infer&#xA;it.&#xA;Fortunately, in that case, type inference is able to infer the type&#xA;argument for &lt;code&gt;E&lt;/code&gt; from the argument for &lt;code&gt;S&lt;/code&gt;, and we don&amp;rsquo;t have to&#xA;specify it separately.&lt;/p&gt;&#xA;&lt;p&gt;That is, we can write&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;    myClone := Clone[MySlice]&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;without having to write&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;    myClone := Clone[MySlice, string]&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;deconstructing-type-parameters&#34;&gt;Deconstructing type parameters&lt;/h2&gt;&#xA;&lt;p&gt;The general technique we&amp;rsquo;ve used here, in which we define one type&#xA;parameter &lt;code&gt;S&lt;/code&gt; using another type parameter &lt;code&gt;E&lt;/code&gt;, is a way to&#xA;deconstruct types in generic function signatures.&#xA;By deconstructing a type, we can name, and constrain, all aspects of&#xA;the type.&lt;/p&gt;&#xA;&lt;p&gt;For example, here is the signature for &lt;code&gt;maps.Clone&lt;/code&gt;.&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;func Clone[M ~map[K]V, K comparable, V any](m M) M&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Just as with &lt;code&gt;slices.Clone&lt;/code&gt;, we use a type parameter for the type of&#xA;the parameter &lt;code&gt;m&lt;/code&gt;, and then deconstruct the type using two other type&#xA;parameters &lt;code&gt;K&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt;.&lt;/p&gt;&#xA;&lt;p&gt;In &lt;code&gt;maps.Clone&lt;/code&gt; we constrain &lt;code&gt;K&lt;/code&gt; to be comparable, as is required for&#xA;a map key type.&#xA;We can constrain the component types any way we like.&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;func WithStrings[S ~[]E, E interface { String() string }](s S) (S, []string)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;This says that the argument of &lt;code&gt;WithStrings&lt;/code&gt; must be a slice type for&#xA;which the element type has a &lt;code&gt;String&lt;/code&gt; method.&lt;/p&gt;&#xA;&lt;p&gt;Since all Go types can be built up from component types, we can always&#xA;use type parameters to deconstruct those types and constrain them as&#xA;we like.&lt;/p&gt;&#xA;&#xA;    &lt;/div&gt;&#xA;&#xA;    &#xA;    &lt;div class=&#34;Article prevnext&#34;&gt;&#xA;    &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;        &lt;p&gt;&#xA;        &#xA;          &#xA;            &lt;b&gt;Next article: &lt;/b&gt;&lt;a href=&#34;/blog/type-inference&#34;&gt;Everything You Always Wanted to Know About Type Inference - And a Little Bit More&lt;/a&gt;&lt;br&gt;&#xA;          &#xA;        &#xA;        &#xA;          &#xA;            &lt;b&gt;Previous article: &lt;/b&gt;&lt;a href=&#34;/blog/loopvar-preview&#34;&gt;Fixing For Loops in Go 1.22&lt;/a&gt;&lt;br&gt;&#xA;          &#xA;        &#xA;        &lt;b&gt;&lt;a href=&#34;/blog/all&#34;&gt;Blog Index&lt;/a&gt;&lt;/b&gt;&#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;    &lt;/div&gt;&#xA;    &#xA;&#xA;  &lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;script src=&#34;/js/jquery.js&#34;&gt;&lt;/script&gt;&#xA;&lt;script src=&#34;/js/playground.js&#34;&gt;&lt;/script&gt;&#xA;&lt;script src=&#34;/js/play.js&#34;&gt;&lt;/script&gt;&#xA;&lt;script src=&#34;/js/godocs.js&#34;&gt;&lt;/script&gt;&#xA;&#xA;</content></entry><entry><title>Fixing For Loops in Go 1.22</title><id>tag:blog.golang.org,2013:blog.golang.org/loopvar-preview</id><link rel="alternate" href="https://go.dev/blog/loopvar-preview"></link><published>2023-09-19T00:00:00+00:00</published><updated>2023-09-19T00:00:00+00:00</updated><author><name></name></author><summary type="html">Go 1.21 shipped a preview of a change in Go 1.22 to make for loops less error-prone.</summary><content type="html">&#xA;&lt;div id=&#34;blog&#34;&gt;&lt;div id=&#34;content&#34;&gt;&#xA;  &lt;div id=&#34;content&#34;&gt;&#xA;&#xA;    &lt;div class=&#34;Article&#34; data-slug=&#34;/blog/loopvar-preview&#34;&gt;&#xA;    &#xA;    &lt;h1 class=&#34;small&#34;&gt;&lt;a href=&#34;/blog/&#34;&gt;The Go Blog&lt;/a&gt;&lt;/h1&gt;&#xA;    &#xA;&#xA;    &lt;h1&gt;Fixing For Loops in Go 1.22&lt;/h1&gt;&#xA;      &#xA;      &lt;p class=&#34;author&#34;&gt;&#xA;      David Chase and Russ Cox&lt;br&gt;&#xA;      19 September 2023&#xA;      &lt;/p&gt;&#xA;      &#xA;      &lt;p&gt;Go 1.21 includes a preview of a change to &lt;code&gt;for&lt;/code&gt; loop scoping&#xA;that we plan to ship in Go 1.22,&#xA;removing one of the most common Go mistakes.&lt;/p&gt;&#xA;&lt;h2 id=&#34;the-problem&#34;&gt;The Problem&lt;/h2&gt;&#xA;&lt;p&gt;If you’ve written any amount of Go code, you’ve probably made the mistake&#xA;of keeping a reference to a loop variable past the end of its iteration,&#xA;at which point it takes on a new value that you didn’t want.&#xA;For example, consider this program:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;func main() {&#xA;    done := make(chan bool)&#xA;&#xA;    values := []string{&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;}&#xA;    for _, v := range values {&#xA;        go func() {&#xA;            fmt.Println(v)&#xA;            done &amp;lt;- true&#xA;        }()&#xA;    }&#xA;&#xA;    // wait for all goroutines to complete before exiting&#xA;    for _ = range values {&#xA;        &amp;lt;-done&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;The three created goroutines are all printing the same variable &lt;code&gt;v&lt;/code&gt;,&#xA;so they usually print “c”, “c”, “c”, instead of printing “a”, “b”, and “c” in some order.&lt;/p&gt;&#xA;&lt;p&gt;The &lt;a href=&#34;/doc/faq#closures_and_goroutines&#34;&gt;Go FAQ entry “What happens with closures running as goroutines?”&lt;/a&gt;,&#xA;gives this example and remarks&#xA;“Some confusion may arise when using closures with concurrency.”&lt;/p&gt;&#xA;&lt;p&gt;Although concurrency is often involved, it need not be.&#xA;This example has the same problem but no goroutines:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;func main() {&#xA;    var prints []func()&#xA;    for i := 1; i &amp;lt;= 3; i++ {&#xA;        prints = append(prints, func() { fmt.Println(i) })&#xA;    }&#xA;    for _, print := range prints {&#xA;        print()&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;This kind of mistake has caused production problems at many companies,&#xA;including a&#xA;&lt;a href=&#34;https://bugzilla.mozilla.org/show_bug.cgi?id=1619047&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;publicly documented issue at Lets Encrypt&lt;/a&gt;.&#xA;In that instance, the accidental capture of the loop variable was spread across&#xA;multiple functions and much more difficult to notice:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;// authz2ModelMapToPB converts a mapping of domain name to authz2Models into a&#xA;// protobuf authorizations map&#xA;func authz2ModelMapToPB(m map[string]authz2Model) (*sapb.Authorizations, error) {&#xA;    resp := &amp;amp;sapb.Authorizations{}&#xA;    for k, v := range m {&#xA;        // Make a copy of k because it will be reassigned with each loop.&#xA;        kCopy := k&#xA;        authzPB, err := modelToAuthzPB(&amp;amp;v)&#xA;        if err != nil {&#xA;            return nil, err&#xA;        }&#xA;        resp.Authz = append(resp.Authz, &amp;amp;sapb.Authorizations_MapElement{&#xA;            Domain: &amp;amp;kCopy,&#xA;            Authz: authzPB,&#xA;        })&#xA;    }&#xA;    return resp, nil&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;The author of this code clearly understood the general problem, because they made a copy of &lt;code&gt;k&lt;/code&gt;,&#xA;but it turns out &lt;code&gt;modelToAuthzPB&lt;/code&gt; used pointers to fields in &lt;code&gt;v&lt;/code&gt; when constructing its result,&#xA;so the loop also needed to make a copy of &lt;code&gt;v&lt;/code&gt;.&lt;/p&gt;&#xA;&lt;p&gt;Tools have been written to identify these mistakes, but it is hard to analyze&#xA;whether references to a variable outlive its iteration or not.&#xA;These tools must choose between false negatives and false positives.&#xA;The &lt;code&gt;loopclosure&lt;/code&gt; analyzer used by &lt;code&gt;go vet&lt;/code&gt; and &lt;code&gt;gopls&lt;/code&gt; opts for false negatives,&#xA;only reporting when it is sure there is a problem but missing others.&#xA;Other checkers opt for false positives, accusing correct code of being incorrect.&#xA;We ran an analysis of commits adding &lt;code&gt;x := x&lt;/code&gt; lines in open-source Go code,&#xA;expecting to find bug fixes.&#xA;Instead we found many unnecessary lines being added,&#xA;suggesting instead that popular checkers have significant false positive rates,&#xA;but developers add the lines anyway to keep the checkers happy.&lt;/p&gt;&#xA;&lt;p&gt;One pair of examples we found was particularly illuminating:&lt;/p&gt;&#xA;&lt;p&gt;This diff was in one program:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;     for _, informer := range c.informerMap {&#xA;+        informer := informer&#xA;         go informer.Run(stopCh)&#xA;     }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;And this diff was in another program:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;     for _, a := range alarms {&#xA;+        a := a&#xA;         go a.Monitor(b)&#xA;     }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;One of these two diffs is a bug fix; the other is an unnecessary change.&#xA;You can’t tell which is which unless you know more about the types&#xA;and functions involved.&lt;/p&gt;&#xA;&lt;h2 id=&#34;the-fix&#34;&gt;The Fix&lt;/h2&gt;&#xA;&lt;p&gt;For Go 1.22, we plan to change &lt;code&gt;for&lt;/code&gt; loops to make these variables have&#xA;per-iteration scope instead of per-loop scope.&#xA;This change will fix the examples above, so that they are no longer buggy Go programs;&#xA;it will end the production problems caused by such mistakes;&#xA;and it will remove the need for imprecise tools that prompt users&#xA;to make unnecessary changes to their code.&lt;/p&gt;&#xA;&lt;p&gt;To ensure backwards compatibility with existing code, the new semantics&#xA;will only apply in packages contained in modules that declare &lt;code&gt;go 1.22&lt;/code&gt; or&#xA;later in their &lt;code&gt;go.mod&lt;/code&gt; files.&#xA;This per-module decision provides developer control of a gradual update&#xA;to the new semantics throughout a codebase.&#xA;It is also possible to use &lt;code&gt;//go:build&lt;/code&gt; lines to control the decision on a&#xA;per-file basis.&lt;/p&gt;&#xA;&lt;p&gt;Old code will continue to mean exactly what it means today:&#xA;the fix only applies to new or updated code.&#xA;This will give developers control over when the semantics change&#xA;in a particular package.&#xA;As a consequence of our &lt;a href=&#34;toolchain&#34;&gt;forward compatibility work&lt;/a&gt;,&#xA;Go 1.21 will not attempt to compile code that declares &lt;code&gt;go 1.22&lt;/code&gt; or later.&#xA;We included a special case with the same effect in&#xA;the point releases Go 1.20.8 and Go 1.19.13,&#xA;so when Go 1.22 is released,&#xA;code written depending on the new semantics will never be compiled with&#xA;the old semantics, unless people are using very old, &lt;a href=&#34;/doc/devel/release#policy&#34;&gt;unsupported Go versions&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;h2 id=&#34;previewing-the-fix&#34;&gt;Previewing The Fix&lt;/h2&gt;&#xA;&lt;p&gt;Go 1.21 includes a preview of the scoping change.&#xA;If you compile your code with &lt;code&gt;GOEXPERIMENT=loopvar&lt;/code&gt; set in your environment,&#xA;then the new semantics are applied to all loops&#xA;(ignoring the &lt;code&gt;go.mod&lt;/code&gt; &lt;code&gt;go&lt;/code&gt; lines).&#xA;For example, to check whether your tests still pass with the new loop semantics&#xA;applied to your package and all your dependencies:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;GOEXPERIMENT=loopvar go test&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;We patched our internal Go toolchain at Google to force this mode during all builds&#xA;at the start of May 2023, and in the past four months&#xA;we have had zero reports of any problems in production code.&lt;/p&gt;&#xA;&lt;p&gt;You can also try test programs to better understand the semantics&#xA;on the Go playground by including a &lt;code&gt;// GOEXPERIMENT=loopvar&lt;/code&gt; comment&#xA;at the top of the program, like in &lt;a href=&#34;/play/p/YchKkkA1ETH&#34;&gt;this program&lt;/a&gt;.&#xA;(This comment only applies in the Go playground.)&lt;/p&gt;&#xA;&lt;h2 id=&#34;fixing-buggy-tests&#34;&gt;Fixing Buggy Tests&lt;/h2&gt;&#xA;&lt;p&gt;Although we’ve had no production problems,&#xA;to prepare for that switch, we did have to correct many buggy tests that were not&#xA;testing what they thought they were, like this:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;func TestAllEvenBuggy(t *testing.T) {&#xA;    testCases := []int{1, 2, 4, 6}&#xA;    for _, v := range testCases {&#xA;        t.Run(&amp;quot;sub&amp;quot;, func(t *testing.T) {&#xA;            t.Parallel()&#xA;            if v&amp;amp;1 != 0 {&#xA;                t.Fatal(&amp;quot;odd v&amp;quot;, v)&#xA;            }&#xA;        })&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;In Go 1.21, this test passes because &lt;code&gt;t.Parallel&lt;/code&gt; blocks each subtest&#xA;until the entire loop has finished and then runs all the subtests&#xA;in parallel. When the loop has finished, &lt;code&gt;v&lt;/code&gt; is always 6,&#xA;so the subtests all check that 6 is even,&#xA;so the test passes.&#xA;Of course, this test really should fail, because 1 is not even.&#xA;Fixing for loops exposes this kind of buggy test.&lt;/p&gt;&#xA;&lt;p&gt;To help prepare for this kind of discovery, we improved the precision&#xA;of the &lt;code&gt;loopclosure&lt;/code&gt; analyzer in Go 1.21 so that it can identify and&#xA;report this problem.&#xA;You can see the report &lt;a href=&#34;/play/p/WkJkgXRXg0m&#34;&gt;in this program&lt;/a&gt; on the Go playground.&#xA;If &lt;code&gt;go vet&lt;/code&gt; is reporting this kind of problem in your own tests,&#xA;fixing them will prepare you better for Go 1.22.&lt;/p&gt;&#xA;&lt;p&gt;If you run into other problems,&#xA;&lt;a href=&#34;/wiki/LoopvarExperiment#my-test-fails-with-the-change-how-can-i-debug-it&#34;&gt;the FAQ&lt;/a&gt;&#xA;has links to examples and details about using a tool we’ve written to identify&#xA;which specific loop is causing a test failure when the new semantics are applied.&lt;/p&gt;&#xA;&lt;h2 id=&#34;more-information&#34;&gt;More Information&lt;/h2&gt;&#xA;&lt;p&gt;For more information about the change, see the&#xA;&lt;a href=&#34;https://go.googlesource.com/proposal/+/master/design/60078-loopvar.md&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;design document&lt;/a&gt;&#xA;and the&#xA;&lt;a href=&#34;/wiki/LoopvarExperiment&#34;&gt;FAQ&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;    &lt;/div&gt;&#xA;&#xA;    &#xA;    &lt;div class=&#34;Article prevnext&#34;&gt;&#xA;    &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;        &lt;p&gt;&#xA;        &#xA;          &#xA;            &lt;b&gt;Next article: &lt;/b&gt;&lt;a href=&#34;/blog/deconstructing-type-parameters&#34;&gt;Deconstructing Type Parameters&lt;/a&gt;&lt;br&gt;&#xA;          &#xA;        &#xA;        &#xA;          &#xA;            &lt;b&gt;Previous article: &lt;/b&gt;&lt;a href=&#34;/blog/wasi&#34;&gt;WASI support in Go&lt;/a&gt;&lt;br&gt;&#xA;          &#xA;        &#xA;        &lt;b&gt;&lt;a href=&#34;/blog/all&#34;&gt;Blog Index&lt;/a&gt;&lt;/b&gt;&#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;    &lt;/div&gt;&#xA;    &#xA;&#xA;  &lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;script src=&#34;/js/jquery.js&#34;&gt;&lt;/script&gt;&#xA;&lt;script src=&#34;/js/playground.js&#34;&gt;&lt;/script&gt;&#xA;&lt;script src=&#34;/js/play.js&#34;&gt;&lt;/script&gt;&#xA;&lt;script src=&#34;/js/godocs.js&#34;&gt;&lt;/script&gt;&#xA;&#xA;</content></entry></feed>